<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8">
  <title>Edytor klip√≥w</title>
  <link rel="stylesheet" href="/static/style.css">
  <style>
    .layout { display:flex; gap:16px; }
    .sidebar { width:280px; max-height:80vh; overflow:auto; border-right:1px solid #ddd; padding-right:12px; }
    .clip-item { cursor:pointer; padding:6px; border-radius:6px; }
    .clip-item.active { background:#eef; }
    .player { flex:1; }
    .canvas-wrap { position:relative; width:100%; max-width:960px; }
    .overlay { position:absolute; left:0; top:0; right:0; bottom:0; z-index:2; }
    .overlay.inactive { pointer-events:none; cursor:default; }
    .overlay:not(.inactive) { pointer-events:auto; cursor:crosshair; }
    .crop-rect { position:absolute; border:2px dashed #ff4444; pointer-events:auto; background:transparent; cursor:move; z-index:2; }
    .crop-game { border-color:#ff4444; color:#ff4444; z-index:2; }
    .crop-camera { border-color:#4444ff; color:#4444ff; z-index:3; }
    .crop-rect .handle { position:absolute; width:12px; height:12px; background:#fff; border:2px solid currentColor; border-radius:2px; box-sizing:border-box; }
    .crop-rect .handle.nw { left:-6px; top:-6px; cursor:nwse-resize; }
    .crop-rect .handle.n  { left:50%; top:-6px; transform:translateX(-50%); cursor:ns-resize; }
    .crop-rect .handle.ne { right:-6px; top:-6px; cursor:nesw-resize; }
    .crop-rect .handle.e  { right:-6px; top:50%; transform:translateY(-50%); cursor:ew-resize; }
    .crop-rect .handle.se { right:-6px; bottom:-6px; cursor:nwse-resize; }
    .crop-rect .handle.s  { left:50%; bottom:-6px; transform:translateX(-50%); cursor:ns-resize; }
    .crop-rect .handle.sw { left:-6px; bottom:-6px; cursor:nesw-resize; }
    .crop-rect .handle.w  { left:-6px; top:50%; transform:translateY(-50%); cursor:ew-resize; }
     .toolbar { margin:8px 0; display:flex; gap:8px; align-items:center; }
    .ratio-control { display:flex; align-items:center; gap:8px; margin:8px 0; }
    .ratio-slider { width:200px; }
    .ratio-label { font-size:12px; color:#333; min-width:80px; }
    .snap-control { margin:4px 0 8px; font-size:13px; color:#333; }
     .hint { color:#666; font-size:12px; }
    /* Progress bar */
    .progress { position: relative; background:#f2f2f2; border-radius:6px; height:14px; width:100%; max-width:480px; overflow:hidden; border:1px solid #ddd; }
    .progress-bar { height:100%; width:0%; background:linear-gradient(90deg,#4caf50,#80e27e); transition: width .3s ease; }
    .progress-wrap { display:flex; align-items:center; gap:8px; margin:8px 0; }
    .progress-label { font-size:12px; color:#333; min-width:120px; }
    .status.error { color:#b00020; }
    .preview-col { width:320px; max-width:360px; }
    .timebar { display:flex; align-items:center; gap:8px; margin-top:8px; }
    #time-slider { width:100%; flex:1; }
    .time-label { font-size:12px; color:#333; min-width:84px; text-align:right; }
     .hint { color:#666; font-size:12px; }
    /* Progress bar */
    .progress { position: relative; background:#f2f2f2; border-radius:6px; height:14px; width:100%; max-width:480px; overflow:hidden; border:1px solid #ddd; }
    .progress-bar { height:100%; width:0%; background:linear-gradient(90deg,#4caf50,#80e27e); transition: width .3s ease; }
    .progress-wrap { display:flex; align-items:center; gap:8px; margin:8px 0; }
    .progress-label { font-size:12px; color:#333; min-width:120px; }
    .status.error { color:#b00020; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Edytor klip√≥w</h1>
      <button id="btn-back" class="btn">‚Ü©Ô∏è Wr√≥ƒá</button>
    </header>
    <div id="info" class="status">Inicjalizacja...</div>

    <div class="progress-wrap" id="dl-wrap" hidden>
      <span class="progress-label" id="dl-text">Pobieranie...</span>
      <div class="progress"><div class="progress-bar" id="dl-bar"></div></div>
      <span class="progress-label" id="dl-count"></span>
    </div>

    <div class="layout">
      <aside class="sidebar">
        <h3>Wybrane klipy</h3>
        <ul id="clip-list"></ul>
      </aside>
      <section class="player">
        <div class="toolbar">
          <button id="btn-load-preview" class="btn">Odtwarzaj prewkƒô 540p</button>
          <button id="btn-load-source" class="btn">Odtwarzaj orygina≈Ç</button>
          <button id="btn-toggle-crop" class="btn">‚úÇÔ∏è Zaznacz kadry</button>
           <button id="btn-save-crop" class="btn">üíæ Zapisz kadry</button>
         </div>
        <div class="ratio-control">
          <span class="ratio-label">Podzia≈Ç V:</span>
          <input type="range" id="ratio-slider" class="ratio-slider" min="20" max="80" value="70" step="5">
          <span id="ratio-display" class="ratio-label">70% gra / 30% kamerka</span>
        </div>
        <div class="snap-control"><label><input type="checkbox" id="auto-split-toggle"> Auto podzia≈Ç (wg aspekt√≥w zaznacze≈Ñ)</label></div>
        <div class="hint" id="crop-hint">Kliknij ‚ÄûZaznacz kadry‚Äù, nastƒôpnie: przeciƒÖgnij po pustym miejscu aby narysowaƒá. PrzeciƒÖgnij wewnƒÖtrz aby przesunƒÖƒá. Chwyƒá za krawƒôd≈∫/rogowy uchwyt aby zmieniƒá rozmiar. Shift podczas rysowania = kamerka.</div>
         <div class="canvas-wrap">
           <video id="video" controls style="width:100%; max-width:960px; background:#000;"></video>
           <div id="overlay" class="overlay inactive">
            <div id="crop-game" class="crop-rect crop-game" hidden>
              <div class="handle nw"></div>
              <div class="handle n"></div>
              <div class="handle ne"></div>
              <div class="handle e"></div>
              <div class="handle se"></div>
              <div class="handle s"></div>
              <div class="handle sw"></div>
              <div class="handle w"></div>
            </div>
            <div id="crop-camera" class="crop-rect crop-camera" hidden>
              <div class="handle nw"></div>
              <div class="handle n"></div>
              <div class="handle ne"></div>
              <div class="handle e"></div>
              <div class="handle se"></div>
              <div class="handle s"></div>
              <div class="handle sw"></div>
              <div class="handle w"></div>
            </div>
           </div>
         </div>
      </section>
    </div>
  </div>

  <script id="clips-data" type="application/json">{{ clips | tojson }}</script>
  <script>
    // Wr√≥ƒá bez pe≈Çnego prze≈Çadowania
    document.getElementById('btn-back').addEventListener('click', (e)=>{
      e.preventDefault();
      if (history.length > 1) history.back(); else window.location.assign('/');
    });

    const info = document.getElementById('info');
    const listEl = document.getElementById('clip-list');
    const video = document.getElementById('video');
    const cropGameEl = document.getElementById('crop-game');
    const cropCameraEl = document.getElementById('crop-camera');
    const ratioSlider = document.getElementById('ratio-slider');
    const ratioDisplay = document.getElementById('ratio-display');
    const autoSplitToggle = document.getElementById('auto-split-toggle');
    const cropHint = document.getElementById('crop-hint');
    const dlWrap = document.getElementById('dl-wrap');
    const dlBar = document.getElementById('dl-bar');
    const dlText = document.getElementById('dl-text');
    const dlCount = document.getElementById('dl-count');
    const overlay = document.getElementById('overlay');
    
    // --- Nowy stan dw√≥ch kadr√≥w ---
    const state = { 
      gameRect: null,    // {x,y,w,h} w wsp√≥≈Çrzƒôdnych [0..1]
      cameraRect: null,  // {x,y,w,h} w wsp√≥≈Çrzƒôdnych [0..1]
      gameRatio: 0.7,    // 70% wysoko≈õci dla gry
      validAspect: true, // czy aktualne kadry dajƒÖ 9:16
      dragging: null,    // 'game' | 'camera' | null
      autoSplit: false   // gdy true ‚Äì wysoko≈õci sekcji liczymy z aspekt√≥w zaznacze≈Ñ
    };
    
    // Suwak podzia≈Çu pionowego
    ratioSlider.addEventListener('input', ()=>{
      state.gameRatio = parseInt(ratioSlider.value) / 100;
      const cameraRatio = 1 - state.gameRatio;
      ratioDisplay.textContent = `${Math.round(state.gameRatio*100)}% gra / ${Math.round(cameraRatio*100)}% kamerka`;
      // po zmianie podzia≈Çu przelicz oba kadry, aby zachowaƒá nowe proporcje
      validateAndUpdateVisuals();
    });

    if (autoSplitToggle){
      autoSplitToggle.addEventListener('change', ()=>{
        state.autoSplit = !!autoSplitToggle.checked;
        const controls = document.querySelector('.ratio-control');
        if (controls) controls.style.opacity = state.autoSplit ? '0.5' : '1';
        if (ratioSlider) ratioSlider.disabled = state.autoSplit;
        validateAndUpdateVisuals();
      });
    }
    
   // --- Stan edytora ---
   let clips = JSON.parse(document.getElementById('clips-data').textContent);
   let active = null; // {clip_id, url, broadcaster, title}
   let cropping = false;
   let dragStart = null; // {x,y}
   function setInfo(msg, isError=false){
     info.textContent = msg;
     info.classList.toggle('error', !!isError);
   }
 
     function clipIdFromUrl(url){
       try {
         const u = new URL(url);
         let last = u.pathname.split('/').filter(Boolean).pop() || 'clip';
         last = last.split('?')[0];
         return last.replace(/[^a-zA-Z0-9_-]/g, '') || 'clip';
       } catch { return 'clip'; }
     }
 
     function renderList(){
       listEl.innerHTML = '';
       clips.forEach((c)=>{
         const li = document.createElement('li');
         li.className = 'clip-item' + (active && active.url===c.url ? ' active' : '');
         li.textContent = `${c.broadcaster} - ${c.title}`;
         li.title = c.url;
         li.addEventListener('click', ()=>selectClip(c));
         listEl.appendChild(li);
       });
     }
 
     function selectClip(c){
       active = { ...c, clip_id: clipIdFromUrl(c.url) };
       window.active = active;
       renderList();
       fetch(`/api/crop/${active.clip_id}`).then(r=>r.json()).then(j=>{
         state.gameRect = j.game || null;
         state.cameraRect = j.camera || null;
         updateBothVisuals();
       }).catch(()=>{});
       tryAutoLoadActive();
       video.addEventListener('loadedmetadata', updateBothVisuals, { once: true });
     }
 
     function setVideo(src){
       video.src = src;
       video.play().catch(()=>{});
     }
 
     function tryAutoLoadActive(){
       if (!active) return;
       const previewUrl = `/media/previews/${active.clip_id}.mp4`;
       const origUrl = `/media/clips/${active.clip_id}.mp4`;
       const onErrorOnce = ()=>{
         video.removeEventListener('error', onErrorOnce);
         // fallback do orygina≈Çu
         setVideo(origUrl);
         const onErr2 = ()=>{
           video.removeEventListener('error', onErr2);
           setInfo('Nie uda≈Ço siƒô za≈Çadowaƒá pliku wideo (prewka ani orygina≈Ç).', true);
         };
         video.addEventListener('error', onErr2, { once: true });
       };
       video.addEventListener('error', onErrorOnce, { once: true });
       setVideo(previewUrl);
     }
 
   // Przyciski wyboru √Ö¬∫r√Ö¬≥≈Ça odtwarzania
      const btnPrev = document.getElementById('btn-load-preview');
      const btnSrc = document.getElementById('btn-load-source');
      btnPrev.addEventListener('click', ()=>{
        if (!active) { alert('Najpierw wybierz klip.'); return; }
        const url = `/media/previews/${active.clip_id}.mp4`;
        setVideo(url);
      });
      btnSrc.addEventListener('click', ()=>{
        if (!active) { alert('Najpierw wybierz klip.'); return; }
        const url = `/media/clips/${active.clip_id}.mp4`;
        setVideo(url);
      });
 
      // Geometria wy√Ö‚Ä∫wietlania (bez letterbox)
     function getDisplayBox(){
       const o = overlay.getBoundingClientRect();
       const vw = video.videoWidth || o.width;
       const vh = video.videoHeight || o.height;
       const scale = Math.min(o.width / vw, o.height / vh);
       const dw = vw * scale;
       const dh = vh * scale;
       const offX = (o.width - dw) / 2;
       const offY = (o.height - dh) / 2;
       return { w:o.width, h:o.height, offX, offY, dw, dh };
     }
     function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
     function eventToNorm(e){
       const o = overlay.getBoundingClientRect();
       const p = getDisplayBox();
       const x = clamp(e.clientX - o.left - p.offX, 0, p.dw);
       const y = clamp(e.clientY - o.top - p.offY, 0, p.dh);
       return { x: (x / p.dw), y: (y / p.dh) };
     }
     function desiredAspects(){
       const g = state.gameRatio;
       const c = 1 - g;
       // aspect = width/height w uk≈Çadzie pionowym 9:16
       return { game: 9 / (16 * g), camera: 9 / (16 * c) };
     }
     function enforceAspect(start, current, which){
       const asp = desiredAspects()[which];
       const x0 = clamp(start.x, 0, 1), y0 = clamp(start.y, 0, 1);
       let left = Math.min(x0, current.x), top = Math.min(y0, current.y);
       let w = Math.abs(current.x - x0), h = Math.abs(current.y - y0);
       if (w === 0 && h === 0) return { x:left, y:top, w:0, h:0 };
       if (w / h > asp) { w = h * asp; } else { h = w / asp; }
       if (left + w > 1) w = 1 - left;
       if (top + h > 1) h = 1 - top;
       return { x:left, y:top, w, h };
     }
     function fitAspectAroundCenter(rect, which){
       if (!rect) return rect;
       const asp = desiredAspects()[which];
       // zachowaj ≈õrodek
       let cx = rect.x + rect.w/2, cy = rect.y + rect.h/2;
       // dobierz w/h najbli≈ºsze bie≈ºƒÖcym, ale zgodne z aspectem
       let h = Math.min(rect.h, rect.w / asp);
       let w = asp * h;
       if (w === 0 || h === 0) { w = Math.max(0.02, asp*0.02); h = Math.max(0.02, 0.02); }
       // upewnij siƒô, ≈ºe mie≈õci siƒô w granicach przy sta≈Çym ≈õrodku ‚Äì ewentualnie skaluje siƒô w d√≥≈Ç
       let hx = w/2, hy = h/2;
       const hxMax = Math.min(cx, 1-cx);
       const hyMax = Math.min(cy, 1-cy);
       const s = Math.min(1, hxMax/hx, hyMax/hy);
       w *= s; h *= s; hx = w/2; hy = h/2;
       const x = clamp(cx - hx, 0, 1 - w);
       const y = clamp(cy - hy, 0, 1 - h);
       return { x, y, w, h };
     }
     function updateBothVisuals(){
       const p = getDisplayBox();
       function apply(el, r){
         if (!r) { el.hidden = true; return; }
         el.style.left = (p.offX + r.x * p.dw) + 'px';
         el.style.top = (p.offY + r.y * p.dh) + 'px';
         el.style.width = (r.w * p.dw) + 'px';
         el.style.height = (r.h * p.dh) + 'px';
         el.hidden = false;
       }
       apply(cropGameEl, state.gameRect);
       apply(cropCameraEl, state.cameraRect);
     }
     function validateAndUpdateVisuals(){
      // Nie wymuszaj ≈ºadnego aspektu ani auto-przekszta≈Çce≈Ñ ‚Äì u≈ºytkownik ma pe≈ÇnƒÖ kontrolƒô
      state.validAspect = true;
       setInfo('Tryb edycji: narysuj/edytuj kadry gry (czerwony) i kamerki (niebieski).');
       updateBothVisuals();
     }
 
   // Tryb zaznaczania + rysowanie
     document.getElementById('btn-toggle-crop').addEventListener('click', ()=>{
       if (!active) { alert('Najpierw wybierz klip.'); return; }
       cropping = !cropping;
       video.controls = !cropping;
       overlay.classList.toggle('inactive', !cropping);
       setInfo(cropping ? 'Tryb zaznaczania: przeciƒÖgnij myszƒÖ po wideo. Bez Shift = gra, z przytrzymanym Shift = kamerka.' : 'Tryb zaznaczania wy≈ÇƒÖczony.');
     });

   // --- Nowe sterowanie: rysowanie, przesuwanie i zmiana rozmiaru ---
   let drag = null; // {mode:'draw'|'move'|'resize', which:'game'|'camera', handle?:string, start:{x,y}, rect0?:{x,y,w,h}}

   function startDraw(which, e){
     drag = { mode:'draw', which, start: eventToNorm(e) };
     const r = { x: drag.start.x, y: drag.start.y, w: 0, h: 0 };
     if (which === 'game') state.gameRect = r; else state.cameraRect = r;
     updateBothVisuals();
   }
   function startMove(which, e){
     const r = (which === 'game') ? state.gameRect : state.cameraRect;
     if (!r) return;
     drag = { mode:'move', which, start: eventToNorm(e), rect0: { ...r } };
   }
   function startResize(which, handle, e){
     const r = (which === 'game') ? state.gameRect : state.cameraRect;
     if (!r) return;
     drag = { mode:'resize', which, handle, start: eventToNorm(e), rect0: { ...r } };
   }

   overlay.addEventListener('mousedown', (e)=>{
     if (!active || !cropping) return;
     if (e.target !== overlay) return; // rysuj tylko na pustym tle
     const which = e.shiftKey ? 'camera' : 'game';
     startDraw(which, e);
     e.preventDefault();
   });

   function onRectMouseDown(which, e){
     if (!active || !cropping) return;
     const target = e.target;
     const handles = ['nw','n','ne','e','se','s','sw','w'];
     let handle = null;
     for (const h of handles){ if (target.classList && target.classList.contains(h)) { handle = h; break; } }
     if (handle) startResize(which, handle, e); else startMove(which, e);
     e.preventDefault();
     e.stopPropagation();
   }
   cropGameEl.addEventListener('mousedown', onRectMouseDown.bind(null, 'game'));
   cropCameraEl.addEventListener('mousedown', onRectMouseDown.bind(null, 'camera'));

   window.addEventListener('mousemove', (e)=>{
     if (!drag || !active || !cropping) return;
     const p = eventToNorm(e);
     const which = drag.which;
     const r0 = drag.rect0 || ((which === 'game') ? state.gameRect : state.cameraRect) || {x:drag.start.x, y:drag.start.y, w:0, h:0};
     let rect = null;
     if (drag.mode === 'draw'){
       if (which === 'camera'){
         // swobodne rysowanie dla kamerki ‚Äì ≈Çatwiej trafiƒá w ma≈Çy box
         const left = Math.min(drag.start.x, p.x);
         const top = Math.min(drag.start.y, p.y);
         const right = Math.max(drag.start.x, p.x);
         const bottom = Math.max(drag.start.y, p.y);
         rect = { x: clamp(left,0,1), y: clamp(top,0,1), w: clamp(right,0,1) - clamp(left,0,1), h: clamp(bottom,0,1) - clamp(top,0,1) };
       } else {
         // gra: r√≥wnie≈º swobodne rysowanie (bez wymuszania aspektu)
         const left = Math.min(drag.start.x, p.x);
         const top = Math.min(drag.start.y, p.y);
         const right = Math.max(drag.start.x, p.x);
         const bottom = Math.max(drag.start.y, p.y);
         rect = { x: clamp(left,0,1), y: clamp(top,0,1), w: clamp(right,0,1) - clamp(left,0,1), h: clamp(bottom,0,1) - clamp(top,0,1) };
       }
     } else if (drag.mode === 'move'){
       const dx = p.x - drag.start.x;
       const dy = p.y - drag.start.y;
       let x = clamp(r0.x + dx, 0, 1 - r0.w);
       let y = clamp(r0.y + dy, 0, 1 - r0.h);
       rect = { x, y, w: r0.w, h: r0.h };
     } else if (drag.mode === 'resize'){

const minW = 0.01, minH = 0.01;
// Odczytaj aktualne krawƒôdzie
let left = r0.x, top = r0.y, right = r0.x + r0.w, bottom = r0.y + r0.h;
const onlyVertical = (drag.handle === 'n' || drag.handle === 's');
const onlyHorizontal = (drag.handle === 'w' || drag.handle === 'e');

if (onlyVertical) {
  // zmiana tylko wysoko≈õci (bez wymuszania aspektu)
  if (drag.handle === 'n') top = clamp(p.y, 0, bottom - minH); else bottom = clamp(p.y, top + minH, 1);
  rect = { x: left, y: top, w: right - left, h: bottom - top };
} else if (onlyHorizontal) {
  // zmiana tylko szeroko≈õci (bez wymuszania aspektu)
  if (drag.handle === 'w') left = clamp(p.x, 0, right - minW); else right = clamp(p.x, left + minW, 1);
  rect = { x: left, y: top, w: right - left, h: bottom - top };
} else {
  // uchwyty naro≈ºne ‚Äì niezale≈ºna zmiana szer./wys. bez wymuszania aspektu
  if (drag.handle === 'nw') { left = clamp(p.x, 0, right - minW); top = clamp(p.y, 0, bottom - minH); }
  else if (drag.handle === 'ne') { right = clamp(p.x, left + minW, 1); top = clamp(p.y, 0, bottom - minH); }
  else if (drag.handle === 'sw') { left = clamp(p.x, 0, right - minW); bottom = clamp(p.y, top + minH, 1); }
  else if (drag.handle === 'se') { right = clamp(p.x, left + minW, 1); bottom = clamp(p.y, top + minH, 1); }
  rect = { x: left, y: top, w: right - left, h: bottom - top };
}
     }
     if (which === 'game') state.gameRect = rect; else state.cameraRect = rect;
     updateBothVisuals();
   });
   window.addEventListener('mouseup', ()=>{ 
     // Nie modyfikuj rozmiaru/ratio po puszczeniu myszy ‚Äì pozostaw dok≈Çadnie to, co ustawi≈Ç u≈ºytkownik
     drag = null; 
     validateAndUpdateVisuals();
   });
   window.addEventListener('resize', validateAndUpdateVisuals);
 
   // stara funkcja update usuni√Ñ‚Ñ¢ta - teraz u√Ö¬ºywamy validateAndUpdateVisuals()
 
     let ensureErrorMessage = null;
     async function pollEnsureStatus(totalHint){
       try {
         const r = await fetch('/api/ensure-cache/status', { cache: 'no-store' });
         if (!r.ok) throw new Error('status failed');
         const s = await r.json();
         const total = s.total || totalHint || 0;
         const done = s.done || 0;
         if (total > 0) {
           const pct = Math.max(0, Math.min(100, Math.round((done/total)*100)));
           dlBar.style.width = pct + '%';
           dlCount.textContent = `${done}/${total}`;
         } else {
           dlBar.style.width = '100%';
         }
         if (s.state === 'error') {
           ensureErrorMessage = s.error || s.message || 'B≈ÇƒÖd podczas pobierania';
           return true;
         }
         if (s.state === 'done' || (total && done >= total)) return true;
       } catch (e) {
         // zignoruj chwilowe b√Ö≈Ç√Ñ‚Ñ¢dy
       }
       return false;
     }
 
     async function ensureCacheWithProgress(totalHint){
       if (!clips || clips.length === 0) return;
       dlWrap.hidden = false;
       dlText.textContent = 'Pobieranie i generowanie prewek...';
       dlBar.style.width = '0%';
       dlCount.textContent = `0/${totalHint || clips.length}`;
       setInfo('Trwa przygotowywanie plik√≥w do podglƒÖdu...');
  
       ensureErrorMessage = null;
       const postPromise = fetch('/api/ensure-cache', { method: 'POST' })
         .then(r=>r.json())
         .catch(err=>{
           ensureErrorMessage = err.message;
         });
  
       let done = false;
       while (!done) {
         const sdone = await pollEnsureStatus(totalHint || clips.length);
         if (sdone) done = true; else await new Promise(res=>setTimeout(res, 1000));
       }
       await postPromise;
  
       if (ensureErrorMessage) {
         dlText.textContent = 'B≈ÇƒÖd';
         setInfo('B≈ÇƒÖd pobierania: ' + ensureErrorMessage, true);
         return;
       }
  
       dlText.textContent = 'Zako≈Ñczono';
       dlBar.style.width = '100%';
       setTimeout(()=>{ dlWrap.hidden = true; }, 800);
  
       tryAutoLoadActive();
       setInfo('Gotowe. Mo≈ºesz odtwarzaƒá i kadrowaƒá klipy.');
     }
 
   document.getElementById('btn-save-crop').addEventListener('click', async ()=>{
     if (!active) { alert('Najpierw wybierz klip.'); return; }
     if (!state.gameRect || !state.cameraRect){ alert('Zaznacz obszary dla gry i kamerki.'); return; }
     try {
       const [r1, r2] = await Promise.all([
         fetch('/api/crop', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ clip_id: active.clip_id, rect: state.gameRect, kind: 'game' }) }),
         fetch('/api/crop', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ clip_id: active.clip_id, rect: state.cameraRect, kind: 'camera' }) })
       ]);
       if (!r1.ok) throw new Error(await r1.text());
       if (!r2.ok) throw new Error(await r2.text());
       setInfo('Zapisano kadry (gra i kamerka) dla ' + active.clip_id);
     } catch (e) {
       setInfo('B≈ÇƒÖd zapisu kadr√≥w: ' + e.message, true);
       alert('B≈ÇƒÖd zapisu kadr√≥w: ' + e.message);
     }
   });
 
     // Bootstrap wyboru z localStorage -> backend, potem auto-start ensure-cache, auto-select first
     (async function bootstrap(){
       try {
         let posted = false;
         const raw = localStorage.getItem('pendingSelection');
         if (raw) {
           const payload = JSON.parse(raw);
           if (payload && Array.isArray(payload.clips) && payload.clips.length) {
             setInfo('Zapisujƒô wyb√≥r klip√≥w...');
             const res = await fetch('/api/selection', {
               method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
             });
             if (res.ok) {
               localStorage.removeItem('pendingSelection');
               // zaktualizuj lokalny stan listy klip√≥w bez prze≈Çadowania
               clips = payload.clips;
               renderList();
               posted = true;
              setInfo(`Wybrano ${clips.length} klip√≥w.`);
             }
           }
         }
         if (!clips || clips.length === 0) {
           setInfo('Brak wybranych klip√≥w. Wr√≥ƒá do raportu i zaznacz klipy.', true);
           return;
         }
         // auto-select pierwszego
         selectClip(clips[0]);
         // automatycznie zacznij pobieranie + prewki
         ensureCacheWithProgress(clips.length);
       } catch(e) {
         console.error(e);
         setInfo('WystƒÖpi≈Ç b≈ÇƒÖd inicjalizacji edytora: ' + e.message, true);
       }
     })();
  (function(){
    try{
      const cleanTail = ()=>{
        const body = document.body;
        let n = body && body.lastChild;
        let guard = 0;
        while(n && guard++ < 5000){
          if (n.nodeType === Node.TEXT_NODE && /^[\s}\)]+$/.test(n.textContent||'')){
            const prev = n.previousSibling; body.removeChild(n); n = prev; continue;
          }
          n = n.previousSibling;
        }
      };
      if (document.readyState === 'loading'){
        document.addEventListener('DOMContentLoaded', cleanTail, { once: true });
      } else { cleanTail(); }
    }catch(e){}
  })();
  </script>

  <!-- Panel podglƒÖdu 9:16 i trimowania -->
  <div style="margin-top:16px; display:flex; gap:24px; align-items:flex-start; flex-wrap:wrap;">
    <div>
      <div style="font-weight:600; margin-bottom:6px;">PodglƒÖd 9:16</div>
      <canvas id="final-preview" width="270" height="480" style="background:#000; border:1px solid #999; border-radius:6px; display:block;"></canvas>
    </div>
    <div style="min-width:260px;">
      <div style="font-weight:600; margin-bottom:6px;">Trim</div>
      <div class="timebar"><span class="time-label" id="time-label">0:00 / 0:00</span><input id="time-slider" type="range" min="0" value="0" step="0.01"></div>
      <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:6px;">
        <label>Start (s): <input id="trim-start" type="number" step="0.1" min="0" style="width:90px"></label>
        <button id="btn-set-start" class="btn" type="button">Ustaw = czas</button>
      </div>
      <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:6px;">
        <label>Koniec (s): <input id="trim-end" type="number" step="0.1" min="0" style="width:90px"></label>
        <button id="btn-set-end" class="btn" type="button">Ustaw = czas</button>
      </div>
      <div style="margin-top:10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
        <button id="btn-transcribe" class="btn" type="button">üìù Transkrybuj SRT</button>
        <span id="srt-status" style="color:#555"></span>
        <a id="srt-link" href="#" target="_blank" style="display:none;">Pobierz SRT</a>
      </div>
      <div style="margin-top:10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
        <button id="btn-render" class="btn" type="button">üé¨ Renderuj 1080x1920</button>
        <a id="render-link" href="#" target="_blank" style="display:none;">Pobierz wynik</a>
        <button id="btn-publish" class="btn" type="button" style="display:none;">üì£ Opublikuj‚Ä¶</button>
        <div id="publish-panel" style="display:none; gap:8px; align-items:center; flex-wrap:wrap; margin-top:6px; background:#f6f6f6; padding:8px; border-radius:6px;">
          <label style="display:flex; align-items:center; gap:6px;">
            <input type="radio" name="publish_mode" id="pub-now" value="now" checked>
            <span>Publikuj teraz</span>
          </label>
          <label style="display:flex; align-items:center; gap:6px;">
            <input type="radio" name="publish_mode" id="pub-sched" value="schedule">
            <span>Zaplanuj publikacjƒô</span>
          </label>
          <div id="pub-accounts" style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
            <span style="color:#555;">Konta:</span>
            <span id="pub-accounts-loading" style="color:#888;">≈Åadowanie kont‚Ä¶</span>
          </div>
          <input type="datetime-local" id="pub-time" style="display:none;" />
          <input type="text" id="pub-caption" placeholder="Podpis posta (opcjonalny)" style="min-width:260px;" />
          <button id="btn-publish-confirm" class="btn" type="button">Wy≈õlij</button>
          <span id="publish-status" style="color:#555"></span>
        </div>
        <span id="karaoke-status" style="color:#555; display:none;">Karaoke: ‚Äî</span>
      </div>
    </div>
  </div>

  <script>
  const previewCanvas = document.getElementById('final-preview');
  const ctxPrev = previewCanvas.getContext('2d');
  const trimStartEl = document.getElementById('trim-start');
  const trimEndEl = document.getElementById('trim-end');
  const btnSetStart = document.getElementById('btn-set-start');
  const btnSetEnd = document.getElementById('btn-set-end');
  const btnRender = document.getElementById('btn-render');
  const renderLink = document.getElementById('render-link');
  const karaokeStatus = document.getElementById('karaoke-status');
  const timeSlider = document.getElementById('time-slider');
  const timeLabel = document.getElementById('time-label');

  btnSetStart.addEventListener('click', ()=>{ if (video.duration){ trimStartEl.value = video.currentTime.toFixed(2); } });
  btnSetEnd.addEventListener('click', ()=>{ if (video.duration){ trimEndEl.value = video.currentTime.toFixed(2); } });

  function fmtTime(t){ if (!isFinite(t) || t < 0) return '0:00'; const m = Math.floor(t/60); const s = Math.floor(t%60).toString().padStart(2,'0'); return `${m}:${s}`; }
  function updateTimeLabel(){ const cur = isFinite(video.currentTime) ? video.currentTime : 0; const dur = isFinite(video.duration) ? video.duration : 0; timeLabel.textContent = `${fmtTime(cur)} / ${fmtTime(dur)}`; }
  if (timeSlider) {
    video.addEventListener('loadedmetadata', ()=>{ if (isFinite(video.duration)) { timeSlider.max = video.duration.toFixed(2); timeSlider.value = 0; updateTimeLabel(); } });
    video.addEventListener('timeupdate', ()=>{ if (isFinite(video.currentTime)) { timeSlider.value = video.currentTime; updateTimeLabel(); } });
    timeSlider.addEventListener('input', ()=>{ if (isFinite(video.duration)) { const t = parseFloat(timeSlider.value); if (isFinite(t)) video.currentTime = t; } });
  }

  // Przenie≈õ panel podglƒÖdu/trim na prawƒÖ kolumnƒô obok edytora
  (function(){ const side = document.getElementById('side-preview'); const panel = document.getElementById('preview-trim-panel'); if (side && panel) { side.appendChild(panel); panel.style.marginTop = '0'; panel.style.display = 'block'; } })();

  function drawPreview(){
    const w = previewCanvas.width, h = previewCanvas.height;
    ctxPrev.fillStyle = '#000';
    ctxPrev.fillRect(0,0,w,h);
    if (!video.videoWidth || !state.gameRect || !state.cameraRect) return;
    const vw = video.videoWidth, vh = video.videoHeight;
   let topH, botH;
   if (state.autoSplit){
     const aCam = Math.max(1e-6, state.cameraRect.w / Math.max(1e-6, state.cameraRect.h));
     const aGame = Math.max(1e-6, state.gameRect.w / Math.max(1e-6, state.gameRect.h));
     const pCam = 1 / aCam, pGame = 1 / aGame;
     const sum = pCam + pGame;
     topH = Math.max(1, Math.round(h * (pCam / sum)));
     botH = h - topH;
   } else {
     const g = state.gameRatio, c = 1 - g;
     topH = Math.round(h * c);
     botH = h - topH;
   }

    // camera (top) i game (bottom) bez pas√≥w ‚Äì wype≈Çnienie (cover)
    function drawCover(r, dx, dy, dw, dh, relief = 1.0){
      const sx = Math.round(r.x * vw), sy = Math.round(r.y * vh);
      const sw = Math.round(r.w * vw), sh = Math.round(r.h * vh);
      if (sw <= 0 || sh <= 0) return;
      const a = sw / sh, A = dw / dh; // a: aspect ≈∫r√≥d≈Ça, A: aspect celu
      let tw, th; // rozmiar docelowy (mo≈ºe wyjechaƒá poza ramkƒô, canvas przytnie)
      if (a > A) {
        // ≈∫r√≥d≈Ço szersze ni≈º cel ‚Üí dopasuj wysoko≈õƒá, szeroko≈õƒá wyjdzie poza i zostanie przyciƒôta
        th = Math.round(dh * relief);
        tw = Math.round((dh * a) * relief);
      } else {
        // ≈∫r√≥d≈Ço wƒô≈ºsze ‚Üí dopasuj szeroko≈õƒá, wysoko≈õƒá wyjdzie poza i zostanie przyciƒôta
        tw = Math.round(dw * relief);
        th = Math.round((dw / a) * relief);
      }
      const ox = dx + Math.round((dw - tw)/2);
      const oy = dy + Math.round((dh - th)/2);
      ctxPrev.drawImage(video, sx, sy, sw, sh, ox, oy, tw, th);
    }

    // camera (top) i game (bottom) ‚Äì cover; ujednolicone bez reliefu, aby odzwierciedlaƒá eksport 1:1
    drawCover(state.cameraRect, 0, 0, w, topH, 1.0);
    drawCover(state.gameRect, 0, topH, w, botH, 1.0);
  }
  function previewLoop(){
    try{ drawPreview(); }catch(e){}
    requestAnimationFrame(previewLoop);
  }
  previewLoop();

  btnRender.addEventListener('click', async ()=>{
    if (!active){ alert('Najpierw wybierz klip.'); return; }
    if (!state.gameRect || !state.cameraRect){ alert('Najpierw zaznacz oba kadry.'); return; }
    const start = parseFloat(trimStartEl.value);
    const end = parseFloat(trimEndEl.value);
    const payload = {
      clip_id: active.clip_id,
      game: state.gameRect,
      camera: state.cameraRect,
      game_ratio: state.gameRatio,
      auto_split: !!state.autoSplit,
      start: isFinite(start) ? start : null,
      end: isFinite(end) ? end : null
    };
    setInfo('Render w toku...');
    renderLink.style.display = 'none';
    if (karaokeStatus){ karaokeStatus.style.display = 'inline-block'; karaokeStatus.textContent = 'Karaoke: (w toku...)'; }
    try{
      const r = await fetch('/api/render', { method:'POST', headers:{'Content-Type':'application/json'}, cache:'no-store', body: JSON.stringify(payload)});
      const j = await r.json();
      if (!j.ok){ setInfo('B≈ÇƒÖd renderu: ' + (j.error || '')); if (karaokeStatus){ karaokeStatus.textContent = 'Karaoke: b≈ÇƒÖd'; } return; }
      renderLink.href = j.url; renderLink.style.display = 'inline-block';
      const btnPublish = document.getElementById('btn-publish'); if (btnPublish) btnPublish.style.display = 'inline-block';
      const kinfo = (j.karaoke ? ` (karaoke: ${j.karaoke})` : '');
      if (karaokeStatus){ karaokeStatus.style.display = 'inline-block'; karaokeStatus.textContent = `Karaoke: ${j.karaoke || 'brak'}`; }
      setInfo('Render zako≈Ñczony.' + kinfo);
    }catch(e){ setInfo('B≈ÇƒÖd renderu: ' + e.message, true); if (karaokeStatus){ karaokeStatus.textContent = 'Karaoke: b≈ÇƒÖd'; } }
  });
  </script>

  <script>
  (function(){
    const btnTranscribe = document.getElementById('btn-transcribe');
    const srtStatus = document.getElementById('srt-status');
    const srtLink = document.getElementById('srt-link');
    function resetSrtUi(){ srtStatus.textContent = ''; srtLink.style.display = 'none'; srtLink.href = '#'; }
    async function pollTranscribe(clip_id){
      try{
        const r = await fetch(`/api/transcribe/status?clip_id=${encodeURIComponent(clip_id)}`, { cache:'no-store' });
        if (!r.ok) throw new Error('status failed');
        const j = await r.json();
        if (j.state === 'done' && j.url){ srtStatus.textContent = 'Gotowe'; srtLink.href = j.url; srtLink.style.display = 'inline-block'; return true; }
        if (j.state === 'error'){ srtStatus.textContent = 'B≈ÇƒÖd: ' + (j.error || ''); return true; }
        if (j.state === 'running'){ srtStatus.textContent = 'Trwa transkrypcja...'; return false; }
      }catch(e){ /* ignore transient */ }
      return false;
    }
    async function startTranscribe(){
      if (!window.active){ alert('Najpierw wybierz klip.'); return; }
      resetSrtUi(); srtStatus.textContent = 'Uruchamianie...';
      try{
        const r = await fetch('/api/transcribe', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ clip_id: window.active.clip_id }) });
        const j = await r.json();
        if (!r.ok || j.ok === false){ srtStatus.textContent = 'B≈ÇƒÖd: ' + (j.error || ''); return; }
        if (j.state === 'done' && j.url){ srtStatus.textContent = 'Gotowe'; srtLink.href = j.url; srtLink.style.display = 'inline-block'; return; }
        srtStatus.textContent = 'Trwa transkrypcja...';
        let done = false;
        while(!done){
          done = await pollTranscribe(window.active.clip_id);
          if (!done) await new Promise(res=>setTimeout(res, 1500));
        }
      }catch(e){ srtStatus.textContent = 'B≈ÇƒÖd: ' + e.message; }
    }
    if (btnTranscribe) btnTranscribe.addEventListener('click', startTranscribe);

    const _origSelectClip = window.selectClip;
    window.selectClip = function(c){
      _origSelectClip(c);
      resetSrtUi();
      // Resetuj status karaoke po zmianie klipu
      try {
        const ks = document.getElementById('karaoke-status');
        if (ks){ ks.style.display = 'none'; ks.textContent = 'Karaoke: ‚Äî'; }
      } catch(e){}
      if (window.active && window.active.clip_id){ pollTranscribe(window.active.clip_id); }
    };
    window.resetSrtUi = resetSrtUi;
    window.pollTranscribe = pollTranscribe;
  })();
  </script>

  <script>
  (function(){
    const btnPublish = document.getElementById('btn-publish');
    const publishPanel = document.getElementById('publish-panel');
    const pubNow = document.getElementById('pub-now');
    const pubSched = document.getElementById('pub-sched');
    const pubTime = document.getElementById('pub-time');
    const pubCaption = document.getElementById('pub-caption');
    const btnPublishConfirm = document.getElementById('btn-publish-confirm');
    const publishStatus = document.getElementById('publish-status');
    const renderLink = document.getElementById('render-link');
    const pubAccounts = document.getElementById('pub-accounts');
    const pubAccountsLoading = document.getElementById('pub-accounts-loading');

    async function loadPublerAccounts(){
      if (!pubAccounts || pubAccounts.dataset.loaded === '1') return;
      try{
        if (pubAccountsLoading) pubAccountsLoading.style.display = 'inline';
        // Try using default workspace from .env first
        let res = await fetch('/api/publer/accounts', { cache:'no-store' });
        let j = await res.json().catch(()=>({}));
        if (!res.ok || j.ok === false){
          // Fallback: get first workspace, then accounts
          const ws = await fetch('/api/publer/workspaces', { cache:'no-store' });
          const wj = await ws.json().catch(()=>({}));
          let workspaces = (wj && wj.data && (wj.data.data || wj.data)) || [];
          if (!Array.isArray(workspaces) && workspaces && workspaces.data) workspaces = workspaces.data;
          const firstWs = Array.isArray(workspaces) && workspaces.length ? workspaces[0] : null;
          if (!firstWs || !firstWs.id){ throw new Error('Brak workspace w Publer.'); }
          const url = `/api/publer/accounts?workspace_id=${encodeURIComponent(firstWs.id)}`;
          res = await fetch(url, { cache:'no-store' });
          j = await res.json().catch(()=>({}));
          if (!res.ok || j.ok === false){ throw new Error(j && (j.error || j.status_code) || 'Nie uda≈Ço siƒô pobraƒá kont.'); }
        }
        let accounts = (j && j.data && (j.data.data || j.data)) || [];
        if (!Array.isArray(accounts) && accounts && accounts.data) accounts = accounts.data;
        // Render checkboxes, default all checked
        if (pubAccountsLoading) pubAccountsLoading.remove();
        const title = document.createElement('span'); title.style.color = '#555'; title.textContent = 'Konta:';
        if (!pubAccounts.querySelector('span')) pubAccounts.prepend(title);
        accounts.forEach(acc => {
          const accId = acc.id || acc._id || acc.account_id;
          if (!accId) return;
          const label = document.createElement('label');
          label.style.display = 'flex';
          label.style.alignItems = 'center';
          label.style.gap = '6px';
          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.name = 'pub-acct';
          cb.value = accId;
          cb.checked = true; // default: publish to all
          const name = acc.username || acc.name || acc.title || '';
          const provider = (acc.provider || acc.type || '').toString();
          const text = provider ? `${name} (${provider})` : name || accId;
          const span = document.createElement('span'); span.textContent = text;
          label.appendChild(cb); label.appendChild(span);
          pubAccounts.appendChild(label);
        });
        pubAccounts.dataset.loaded = '1';
      }catch(e){
        if (pubAccountsLoading) pubAccountsLoading.textContent = 'Nie uda≈Ço siƒô za≈Çadowaƒá kont: ' + e.message;
      }
    }

    btnPublish?.addEventListener('click', async ()=>{
      if (!window.active){ alert('Najpierw wybierz klip.'); return; }
      const willShow = (publishPanel.style.display === 'none' || publishPanel.style.display === '');
      publishPanel.style.display = willShow ? 'flex' : 'none';
      publishStatus.textContent = '';
      if (willShow){ await loadPublerAccounts(); }
    });
    pubNow?.addEventListener('change', ()=>{ if (pubNow.checked){ pubTime.style.display = 'none'; }});
    pubSched?.addEventListener('change', ()=>{ if (pubSched.checked){ pubTime.style.display = 'inline-block'; }});
    btnPublishConfirm?.addEventListener('click', async ()=>{
      try{
        if (!window.active){ alert('Najpierw wybierz klip.'); return; }
        if (!renderLink.href || renderLink.style.display === 'none'){
          alert('Najpierw wyrenderuj klip.'); return;
        }
        publishStatus.textContent = 'Wysy≈Çam‚Ä¶';
        const clip_id = window.active.clip_id;
        const body = { caption: pubCaption.value || undefined };
        if (pubSched.checked){
          const dt = pubTime.value; // yyyy-MM-ddTHH:mm
          if (!dt){ publishStatus.textContent = 'Wybierz datƒô i czas.'; return; }
          const local = new Date(dt);
          const iso = new Date(local.getTime() - (local.getTimezoneOffset()*60000)).toISOString().slice(0,19) + 'Z';
          body.publish_now = false;
          body.scheduled_at = iso;
        } else {
          body.publish_now = true;
        }
        // gather selected accounts (default all)
        if (pubAccounts){
          const selected = Array.from(pubAccounts.querySelectorAll('input[name="pub-acct"]:checked')).map(el=>el.value);
          if (selected.length > 0){ body.publer_account_ids = selected; }
        }
        const r = await fetch(`/publish/${encodeURIComponent(clip_id)}`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)});
        const j = await r.json();
        if (!r.ok || j.ok === false){ publishStatus.textContent = 'B≈ÇƒÖd: ' + (j.error || r.statusText); return; }
        if (j.dry_run){ publishStatus.textContent = 'OK (dry-run). Dodaj PUBLER_* do .env aby publikowaƒá.'; }
        else if (j.published){ publishStatus.textContent = 'Opublikowano!'; }
        else { publishStatus.textContent = 'Wys≈Çano. Sprawd≈∫ logi.'; }
      }catch(e){ publishStatus.textContent = 'B≈ÇƒÖd: ' + e.message; }
    });
  })();
  </script>

  <pre style="display:none">
  </pre>
  <script>
    (function(){
      try{
        const pres = document.querySelectorAll('pre[style*="display:none"]');
        const pre = pres[pres.length-1];
        if (pre){
          let n = pre.nextSibling;
          while(n){
            const next = n.nextSibling;
            if (n.nodeType === Node.TEXT_NODE){ n.textContent = ''; }
            else if (n.nodeType === Node.ELEMENT_NODE){ n.style.display = 'none'; }
            n = next;
          }
        }
      }catch(e){/* ignore */}
    })();
  </script>  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
