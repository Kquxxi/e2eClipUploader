<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8">
  <title>Edytor klip√≥w</title>
  <link rel="stylesheet" href="/static/style.css">
  <style>
    .layout { display:flex; gap:16px; }
    .sidebar { width:280px; max-height:80vh; overflow:auto; border-right:1px solid #ddd; padding-right:12px; }
    .clip-item { cursor:pointer; padding:6px; border-radius:6px; }
    .clip-item.active { background:#eef; }
    .player { flex:1; }
    .canvas-wrap { position:relative; width:100%; max-width:960px; }
    .overlay { position:absolute; left:0; top:0; right:0; bottom:0; z-index:2; }
    .overlay.inactive { pointer-events:none; cursor:default; }
    .overlay:not(.inactive) { pointer-events:auto; cursor:crosshair; }
    .crop-rect { position:absolute; border:2px dashed #ff4444; pointer-events:auto; background:transparent; cursor:move; z-index:2; }
    .crop-game { border-color:#ff4444; color:#ff4444; z-index:2; }
    .crop-camera { border-color:#4444ff; color:#4444ff; z-index:3; }
    .crop-rect .handle { position:absolute; width:12px; height:12px; background:#fff; border:2px solid currentColor; border-radius:2px; box-sizing:border-box; }
    .crop-rect .handle.nw { left:-6px; top:-6px; cursor:nwse-resize; }
    .crop-rect .handle.n  { left:50%; top:-6px; transform:translateX(-50%); cursor:ns-resize; }
    .crop-rect .handle.ne { right:-6px; top:-6px; cursor:nesw-resize; }
    .crop-rect .handle.e  { right:-6px; top:50%; transform:translateY(-50%); cursor:ew-resize; }
    .crop-rect .handle.se { right:-6px; bottom:-6px; cursor:nwse-resize; }
    .crop-rect .handle.s  { left:50%; bottom:-6px; transform:translateX(-50%); cursor:ns-resize; }
    .crop-rect .handle.sw { left:-6px; bottom:-6px; cursor:nesw-resize; }
    .crop-rect .handle.w  { left:-6px; top:50%; transform:translateY(-50%); cursor:ew-resize; }
     .toolbar { margin:8px 0; display:flex; gap:8px; align-items:center; }
    .ratio-control { display:flex; align-items:center; gap:8px; margin:8px 0; }
    .ratio-slider { width:200px; }
    .ratio-label { font-size:12px; color:#333; min-width:80px; }
    .snap-control { margin:4px 0 8px; font-size:13px; color:#333; }
     .hint { color:#666; font-size:12px; }
    /* Progress bar */
    .progress { position: relative; background:#f2f2f2; border-radius:6px; height:14px; width:100%; max-width:480px; overflow:hidden; border:1px solid #ddd; }
    .progress-bar { height:100%; width:0%; background:linear-gradient(90deg,#4caf50,#80e27e); transition: width .3s ease; }
    .progress-wrap { display:flex; align-items:center; gap:8px; margin:8px 0; }
    .progress-label { font-size:12px; color:#333; min-width:120px; }
    .status.error { color:#b00020; }
    .preview-col { width:320px; max-width:360px; }
    .timebar { display:flex; align-items:center; gap:8px; margin-top:8px; }
    #time-slider { width:100%; flex:1; }
    .time-label { font-size:12px; color:#333; min-width:84px; text-align:right; }
     .hint { color:#666; font-size:12px; }
    /* Progress bar */
    .progress { position: relative; background:#f2f2f2; border-radius:6px; height:14px; width:100%; max-width:480px; overflow:hidden; border:1px solid #ddd; }
    .progress-bar { height:100%; width:0%; background:linear-gradient(90deg,#4caf50,#80e27e); transition: width .3s ease; }
    .progress-wrap { display:flex; align-items:center; gap:8px; margin:8px 0; }
    .progress-label { font-size:12px; color:#333; min-width:120px; }
    .status.error { color:#b00020; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Edytor klip√≥w</h1>
      <button id="btn-back" class="btn">‚Ü©Ô∏è Wr√≥ƒá</button>
    </header>
    <div id="info" class="status">Inicjalizacja...</div>

    <div class="progress-wrap" id="dl-wrap" hidden>
      <span class="progress-label" id="dl-text">Pobieranie...</span>
      <div class="progress"><div class="progress-bar" id="dl-bar"></div></div>
      <span class="progress-label" id="dl-count"></span>
    </div>

    <div class="layout">
      <aside class="sidebar">
        <h3>Wybrane klipy</h3>
        
        <ul id="clip-list"></ul>
        <div style="margin-top:12px; display:flex; gap:6px;">
          <input id="add-url-input" type="url" placeholder="Wklej link do klipu (Twitch/Kick)" style="flex:1;">
          <button id="btn-add-url" class="btn" type="button">‚ûï Dodaj</button>
        </div>
        <div class="hint">Obs≈Çugiwane: clips.twitch.tv, twitch.tv/.../clip/..., kick.com/[kana≈Ç]/clips/[id]</div>
      </aside>
      <section class="player">
        <div class="toolbar">
          <button id="btn-load-preview" class="btn">Odtwarzaj prewkƒô 540p</button>
          <button id="btn-load-source" class="btn">Odtwarzaj orygina≈Ç</button>
          <button id="btn-toggle-crop" class="btn">‚úÇÔ∏è Zaznacz kadry</button>
           <button id="btn-save-crop" class="btn">üíæ Zapisz kadry</button>
         </div>
        <div class="ratio-control">
          <span class="ratio-label">Podzia≈Ç V:</span>
          <input type="range" id="ratio-slider" class="ratio-slider" min="20" max="80" value="70" step="5">
          <span id="ratio-display" class="ratio-label">70% gra / 30% kamerka</span>
        </div>
        <div class="snap-control"><label><input type="checkbox" id="auto-split-toggle"> Auto podzia≈Ç (wg aspekt√≥w zaznacze≈Ñ)</label></div>
        <div class="snap-control"><label><input type="checkbox" id="single-frame-toggle"> Tryb jednego kadru</label> <span style="margin-left:8px; display:none;" id="single-frame-controls"><span>Wysoko≈õƒá sekcji:</span> <input type="range" id="single-height-slider" min="10" max="100" value="40" step="5"> <span id="single-height-display">40%</span></span></div>
        <div class="hint" id="crop-hint">Kliknij ‚ÄûZaznacz kadry‚Äù, nastƒôpnie: przeciƒÖgnij po pustym miejscu aby narysowaƒá. PrzeciƒÖgnij wewnƒÖtrz aby przesunƒÖƒá. Chwyƒá za krawƒôd≈∫/rogowy uchwyt aby zmieniƒá rozmiar. Shift podczas rysowania = kamerka.</div>
         <div class="canvas-wrap">
           <video id="video" controls style="width:100%; max-width:960px; background:#000;"></video>
           <div id="overlay" class="overlay inactive">
            <div id="crop-game" class="crop-rect crop-game" hidden>
              <div class="handle nw"></div>
              <div class="handle n"></div>
              <div class="handle ne"></div>
              <div class="handle e"></div>
              <div class="handle se"></div>
              <div class="handle s"></div>
              <div class="handle sw"></div>
              <div class="handle w"></div>
            </div>
            <div id="crop-camera" class="crop-rect crop-camera" hidden>
              <div class="handle nw"></div>
              <div class="handle n"></div>
              <div class="handle ne"></div>
              <div class="handle e"></div>
              <div class="handle se"></div>
              <div class="handle s"></div>
              <div class="handle sw"></div>
              <div class="handle w"></div>
            </div>
           </div>
         </div>
      </section>
    </div>
  </div>

  <script id="clips-data" type="application/json">{{ clips | tojson }}</script>
  <script>
    // Wr√≥ƒá bez pe≈Çnego prze≈Çadowania
    document.getElementById('btn-back').addEventListener('click', (e)=>{
      e.preventDefault();
      if (history.length > 1) history.back(); else window.location.assign('/');
    });

    const info = document.getElementById('info');
    const listEl = document.getElementById('clip-list');
    const video = document.getElementById('video');
    const cropGameEl = document.getElementById('crop-game');
    const cropCameraEl = document.getElementById('crop-camera');
    const ratioSlider = document.getElementById('ratio-slider');
    const ratioDisplay = document.getElementById('ratio-display');
    const autoSplitToggle = document.getElementById('auto-split-toggle');
    const cropHint = document.getElementById('crop-hint');
    const dlWrap = document.getElementById('dl-wrap');
    const dlBar = document.getElementById('dl-bar');
    const dlText = document.getElementById('dl-text');
    const dlCount = document.getElementById('dl-count');
    const overlay = document.getElementById('overlay');
    const singleToggle = document.getElementById('single-frame-toggle');
    const singleHeightSlider = document.getElementById('single-height-slider');
    const singleHeightDisplay = document.getElementById('single-height-display');

    
    // --- Stan edytora (tryb dw√≥ch kadr√≥w oraz jednego kadru) ---
    const state = { 
      gameRect: null,    // {x,y,w,h} w [0..1]
      cameraRect: null,  // {x,y,w,h} w [0..1]
      gameRatio: 0.7,    // 70% wysoko≈õci dla gry
      validAspect: true, // czy aktualne kadry dajƒÖ 9:16
      dragging: null,    // 'game' | 'camera' | null
      autoSplit: false,  // gdy true ‚Äì wysoko≈õci sekcji liczymy z aspekt√≥w zaznacze≈Ñ
      singleFrame: false,
      singleHeightRatio: 0.4,
      hideViewed: true
    };

    // Persistencja obejrzanych klip√≥w
    let viewedSet = new Set();
    try { viewedSet = new Set(JSON.parse(localStorage.getItem('viewedClips')||'[]').filter(x=>typeof x==='string')); } catch(e){ viewedSet = new Set(); }
    try { state.hideViewed = JSON.parse(localStorage.getItem('hideViewed')||'true'); } catch(e){ /* keep default */ }

    function markViewed(id){
      if (!id) return;
      if (!viewedSet.has(id)){
        viewedSet.add(id);
        try { localStorage.setItem('viewedClips', JSON.stringify(Array.from(viewedSet))); } catch(e){}
      }
    }
    
    // Suwak podzia≈Çu pionowego
    ratioSlider.addEventListener('input', ()=>{
      state.gameRatio = parseInt(ratioSlider.value) / 100;
      const cameraRatio = 1 - state.gameRatio;
      ratioDisplay.textContent = `${Math.round(state.gameRatio*100)}% gra / ${Math.round(cameraRatio*100)}% kamerka`;
      // po zmianie podzia≈Çu przelicz oba kadry, aby zachowaƒá nowe proporcje
      validateAndUpdateVisuals();
    });

    if (autoSplitToggle){
      autoSplitToggle.addEventListener('change', ()=>{
        state.autoSplit = !!autoSplitToggle.checked;
        const controls = document.querySelector('.ratio-control');
        if (controls) controls.style.opacity = state.autoSplit ? '0.5' : '1';
        if (ratioSlider) ratioSlider.disabled = state.autoSplit;
        validateAndUpdateVisuals();
      });
    }
    if (singleToggle){
      singleToggle.addEventListener('change', ()=>{
        state.singleFrame = !!singleToggle.checked;
        const controls = document.getElementById('single-frame-controls');
        if (controls) controls.style.display = state.singleFrame ? 'inline-flex' : 'none';
        validateAndUpdateVisuals();
      });
    }
    if (singleHeightSlider){
      singleHeightSlider.addEventListener('input', ()=>{
        state.singleHeightRatio = parseInt(singleHeightSlider.value)/100;
        if (singleHeightDisplay) singleHeightDisplay.textContent = `${Math.round(state.singleHeightRatio*100)}%`;
        validateAndUpdateVisuals();
      });
    }
    
   // --- Stan edytora ---
   let clips = [];
   try {
     const el = document.getElementById('clips-data');
     const raw = el ? el.textContent : '';
     clips = JSON.parse(raw || '[]');
   } catch (e) {
     console.error('Failed to parse clips-data:', e);
     setInfo('B≈ÇƒÖd danych klip√≥w: ' + (e.message || e), true);
     clips = [];
   }
   let active = null; // {clip_id, url, broadcaster, title}
   let cropping = false;
   let dragStart = null; // {x,y}
   function setInfo(msg, isError=false){
     info.textContent = msg;
     info.classList.toggle('error', !!isError);
   }
 
     function clipIdFromUrl(url){
       try {
         const u = new URL(url);
         let last = u.pathname.split('/').filter(Boolean).pop() || 'clip';
         last = last.split('?')[0];
         return last.replace(/[^a-zA-Z0-9_-]/g, '') || 'clip';
       } catch { return 'clip'; }
     }
 
     function renderList(){
      listEl.innerHTML = '';
      let newCount = 0;
      (clips || []).forEach((c)=>{
        const id = clipIdFromUrl(c.url);
        const isViewed = viewedSet.has(id);
        const isNew = !isViewed;
        if (isNew) newCount++;
        const shouldHide = state.hideViewed && isViewed && (!active || active.clip_id !== id);
        if (shouldHide) return;
        const li = document.createElement('li');
        li.className = 'clip-item' + (active && active.url===c.url ? ' active' : '');
        li.title = c.url;
        li.addEventListener('click', ()=>selectClip(c));
        const base = document.createElement('span');
        base.textContent = `${c.broadcaster} - ${c.title}`;
        li.appendChild(base);
        if (isNew){
          const badge = document.createElement('span');
          badge.textContent = ' NOWE';
          badge.style.color = '#0a0';
          badge.style.fontWeight = '600';
          badge.style.marginLeft = '6px';
          li.appendChild(badge);
        }
        listEl.appendChild(li);
      });

    }

    // Dodawanie klipu po URL
    (function(){
      const input = document.getElementById('add-url-input');
      const btn = document.getElementById('btn-add-url');
      if (!input || !btn) return;
      async function add(){
        const url = (input.value || '').trim();
        if (!url) { setInfo('Podaj URL klipu.', true); return; }
        setInfo('Dodajƒô klip po URL...');
        try{
          const r = await fetch('/api/add-clip-by-url', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ url }) });
          const j = await r.json();
          if (!r.ok || !j.ok){ setInfo('Nie uda≈Ço siƒô dodaƒá klipu: ' + (j.error || r.statusText), true); return; }
          const clip = j.clip;
          clips = (clips || []).filter(c=>c.url !== clip.url);
          clips.push(clip);
          renderList();
          selectClip(clip);
          setInfo('Dodano klip.');
        }catch(e){ setInfo('B≈ÇƒÖd dodawania klipu: ' + e.message, true); }
      }
      btn.addEventListener('click', add);
      input.addEventListener('keydown', (ev)=>{ if (ev.key === 'Enter') add(); });
    })();
 
    async function selectClip(c){
       active = { ...c, clip_id: clipIdFromUrl(c.url) };
       window.active = active;
       markViewed(active.clip_id);
       renderList();
       fetch(`/api/crop/${active.clip_id}`).then(r=>r.json()).then(j=>{
         state.gameRect = j.game || null;
         state.cameraRect = j.camera || null;
         updateBothVisuals();
       }).catch(()=>{});
       // Preflight: sprawd≈∫ czy pliki istniejƒÖ; je≈õli nie, odpal ensure-cache i poczekaj
       try {
         const headPrev = await fetch(`/media/previews/${active.clip_id}.mp4`, { method: 'HEAD', cache: 'no-store' });
         const headOrig = await fetch(`/media/clips/${active.clip_id}.mp4`, { method: 'HEAD', cache: 'no-store' });
         if (!headPrev.ok && !headOrig.ok) {
           dlWrap.hidden = false;
           dlText.textContent = 'Pobieranie brakujƒÖcych plik√≥w...';
           dlBar.style.width = '0%';
           await ensureCacheWithProgress(clips.length);
         }
       } catch (e) { /* ignore */ }
       tryAutoLoadActive();
       video.addEventListener('loadedmetadata', updateBothVisuals, { once: true });
     }
 
     function setVideo(src){
       video.src = src;
       video.play().catch(()=>{});
     }
 
     function tryAutoLoadActive(){
      if (!active) return;
      // je≈õli trwa ensure-cache (pasek widoczny), wstrzymaj auto-≈Çadowanie do czasu zako≈Ñczenia
      if (typeof dlWrap !== 'undefined' && dlWrap && !dlWrap.hidden) return;
      const previewUrl = `/media/previews/${active.clip_id}.mp4?v=${Date.now()}`;
      const origUrl = `/media/clips/${active.clip_id}.mp4?v=${Date.now()}`;
      const onErrorOnce = ()=>{
        video.removeEventListener('error', onErrorOnce);
        // fallback do orygina≈Çu
        setVideo(origUrl);
        const onErr2 = ()=>{
          video.removeEventListener('error', onErr2);
          setInfo('Nie uda≈Ço siƒô za≈Çadowaƒá pliku wideo (prewka ani orygina≈Ç).', true);
        };
        video.addEventListener('error', onErr2, { once: true });
      };
      video.addEventListener('error', onErrorOnce, { once: true });
      setVideo(previewUrl);
    }
 
   // Przyciski wyboru √Ö¬∫r√Ö¬≥≈Ça odtwarzania
      const btnPrev = document.getElementById('btn-load-preview');
      const btnSrc = document.getElementById('btn-load-source');
      btnPrev.addEventListener('click', ()=>{
        if (!active) { alert('Najpierw wybierz klip.'); return; }
        const url = `/media/previews/${active.clip_id}.mp4?v=${Date.now()}`;
        setVideo(url);
      });
      btnSrc.addEventListener('click', ()=>{
        if (!active) { alert('Najpierw wybierz klip.'); return; }
        const url = `/media/clips/${active.clip_id}.mp4?v=${Date.now()}`;
        setVideo(url);
      });
 
      // Geometria wy√Ö‚Ä∫wietlania (bez letterbox)
     function getDisplayBox(){
       const o = overlay.getBoundingClientRect();
       const vw = video.videoWidth || o.width;
       const vh = video.videoHeight || o.height;
       const scale = Math.min(o.width / vw, o.height / vh);
       const dw = vw * scale;
       const dh = vh * scale;
       const offX = (o.width - dw) / 2;
       const offY = (o.height - dh) / 2;
       return { w:o.width, h:o.height, offX, offY, dw, dh };
     }
     function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
     function eventToNorm(e){
       const o = overlay.getBoundingClientRect();
       const p = getDisplayBox();
       const x = clamp(e.clientX - o.left - p.offX, 0, p.dw);
       const y = clamp(e.clientY - o.top - p.offY, 0, p.dh);
       return { x: (x / p.dw), y: (y / p.dh) };
     }
     function desiredAspects(){
       const g = state.gameRatio;
       const c = 1 - g;
       // aspect = width/height w uk≈Çadzie pionowym 9:16
       return { game: 9 / (16 * g), camera: 9 / (16 * c) };
     }
     function enforceAspect(start, current, which){
       const asp = desiredAspects()[which];
       const x0 = clamp(start.x, 0, 1), y0 = clamp(start.y, 0, 1);
       let left = Math.min(x0, current.x), top = Math.min(y0, current.y);
       let w = Math.abs(current.x - x0), h = Math.abs(current.y - y0);
       if (w === 0 && h === 0) return { x:left, y:top, w:0, h:0 };
       if (w / h > asp) { w = h * asp; } else { h = w / asp; }
       if (left + w > 1) w = 1 - left;
       if (top + h > 1) h = 1 - top;
       return { x:left, y:top, w, h };
     }
     function fitAspectAroundCenter(rect, which){
       if (!rect) return rect;
       const asp = desiredAspects()[which];
       // zachowaj ≈õrodek
       let cx = rect.x + rect.w/2, cy = rect.y + rect.h/2;
       // dobierz w/h najbli≈ºsze bie≈ºƒÖcym, ale zgodne z aspectem
       let h = Math.min(rect.h, rect.w / asp);
       let w = asp * h;
       if (w === 0 || h === 0) { w = Math.max(0.02, asp*0.02); h = Math.max(0.02, 0.02); }
       // upewnij siƒô, ≈ºe mie≈õci siƒô w granicach przy sta≈Çym ≈õrodku ‚Äì ewentualnie skaluje siƒô w d√≥≈Ç
       let hx = w/2, hy = h/2;
       const hxMax = Math.min(cx, 1-cx);
       const hyMax = Math.min(cy, 1-cy);
       const s = Math.min(1, hxMax/hx, hyMax/hy);
       w *= s; h *= s; hx = w/2; hy = h/2;
       const x = clamp(cx - hx, 0, 1 - w);
       const y = clamp(cy - hy, 0, 1 - h);
       return { x, y, w, h };
     }
     function updateBothVisuals(){
       const p = getDisplayBox();
       function apply(el, r){
         if (!r) { el.hidden = true; return; }
         el.style.left = (p.offX + r.x * p.dw) + 'px';
         el.style.top = (p.offY + r.y * p.dh) + 'px';
         el.style.width = (r.w * p.dw) + 'px';
         el.style.height = (r.h * p.dh) + 'px';
         el.hidden = false;
       }
       apply(cropGameEl, state.gameRect);
       apply(cropCameraEl, state.cameraRect);
     }
     function validateAndUpdateVisuals(){
      // Nie wymuszaj ≈ºadnego aspektu ani auto-przekszta≈Çce≈Ñ ‚Äì u≈ºytkownik ma pe≈ÇnƒÖ kontrolƒô
      state.validAspect = true;
       setInfo('Tryb edycji: narysuj/edytuj kadry gry (czerwony) i kamerki (niebieski).');
       updateBothVisuals();
     }
 
   // Tryb zaznaczania + rysowanie
     document.getElementById('btn-toggle-crop').addEventListener('click', ()=>{
       if (!active) { alert('Najpierw wybierz klip.'); return; }
       cropping = !cropping;
       video.controls = !cropping;
       overlay.classList.toggle('inactive', !cropping);
       setInfo(cropping ? 'Tryb zaznaczania: przeciƒÖgnij myszƒÖ po wideo. Bez Shift = gra, z przytrzymanym Shift = kamerka.' : 'Tryb zaznaczania wy≈ÇƒÖczony.');
     });

   // --- Nowe sterowanie: rysowanie, przesuwanie i zmiana rozmiaru ---
   let drag = null; // {mode:'draw'|'move'|'resize', which:'game'|'camera', handle?:string, start:{x,y}, rect0?:{x,y,w,h}}

   function startDraw(which, e){
     drag = { mode:'draw', which, start: eventToNorm(e) };
     const r = { x: drag.start.x, y: drag.start.y, w: 0, h: 0 };
     if (which === 'game') state.gameRect = r; else state.cameraRect = r;
     updateBothVisuals();
   }
   function startMove(which, e){
     const r = (which === 'game') ? state.gameRect : state.cameraRect;
     if (!r) return;
     drag = { mode:'move', which, start: eventToNorm(e), rect0: { ...r } };
   }
   function startResize(which, handle, e){
     const r = (which === 'game') ? state.gameRect : state.cameraRect;
     if (!r) return;
     drag = { mode:'resize', which, handle, start: eventToNorm(e), rect0: { ...r } };
   }

   overlay.addEventListener('mousedown', (e)=>{
     if (!active || !cropping) return;
     if (e.target !== overlay) return; // rysuj tylko na pustym tle
     const which = e.shiftKey ? 'camera' : 'game';
     startDraw(which, e);
     e.preventDefault();
   });

   function onRectMouseDown(which, e){
     if (!active || !cropping) return;
     const target = e.target;
     const handles = ['nw','n','ne','e','se','s','sw','w'];
     let handle = null;
     for (const h of handles){ if (target.classList && target.classList.contains(h)) { handle = h; break; } }
     if (handle) startResize(which, handle, e); else startMove(which, e);
     e.preventDefault();
     e.stopPropagation();
   }
   cropGameEl.addEventListener('mousedown', onRectMouseDown.bind(null, 'game'));
   cropCameraEl.addEventListener('mousedown', onRectMouseDown.bind(null, 'camera'));

   window.addEventListener('mousemove', (e)=>{
     if (!drag || !active || !cropping) return;
     const p = eventToNorm(e);
     const which = drag.which;
     const r0 = drag.rect0 || ((which === 'game') ? state.gameRect : state.cameraRect) || {x:drag.start.x, y:drag.start.y, w:0, h:0};
     let rect = null;
     if (drag.mode === 'draw'){
       if (which === 'camera'){
         // swobodne rysowanie dla kamerki ‚Äì ≈Çatwiej trafiƒá w ma≈Çy box
         const left = Math.min(drag.start.x, p.x);
         const top = Math.min(drag.start.y, p.y);
         const right = Math.max(drag.start.x, p.x);
         const bottom = Math.max(drag.start.y, p.y);
         rect = { x: clamp(left,0,1), y: clamp(top,0,1), w: clamp(right,0,1) - clamp(left,0,1), h: clamp(bottom,0,1) - clamp(top,0,1) };
       } else {
         // gra: r√≥wnie≈º swobodne rysowanie (bez wymuszania aspektu)
         const left = Math.min(drag.start.x, p.x);
         const top = Math.min(drag.start.y, p.y);
         const right = Math.max(drag.start.x, p.x);
         const bottom = Math.max(drag.start.y, p.y);
         rect = { x: clamp(left,0,1), y: clamp(top,0,1), w: clamp(right,0,1) - clamp(left,0,1), h: clamp(bottom,0,1) - clamp(top,0,1) };
       }
     } else if (drag.mode === 'move'){
       const dx = p.x - drag.start.x;
       const dy = p.y - drag.start.y;
       let x = clamp(r0.x + dx, 0, 1 - r0.w);
       let y = clamp(r0.y + dy, 0, 1 - r0.h);
       rect = { x, y, w: r0.w, h: r0.h };
     } else if (drag.mode === 'resize'){

const minW = 0.01, minH = 0.01;
// Odczytaj aktualne krawƒôdzie
let left = r0.x, top = r0.y, right = r0.x + r0.w, bottom = r0.y + r0.h;
const onlyVertical = (drag.handle === 'n' || drag.handle === 's');
const onlyHorizontal = (drag.handle === 'w' || drag.handle === 'e');

if (onlyVertical) {
  // zmiana tylko wysoko≈õci (bez wymuszania aspektu)
  if (drag.handle === 'n') top = clamp(p.y, 0, bottom - minH); else bottom = clamp(p.y, top + minH, 1);
  rect = { x: left, y: top, w: right - left, h: bottom - top };
} else if (onlyHorizontal) {
  // zmiana tylko szeroko≈õci (bez wymuszania aspektu)
  if (drag.handle === 'w') left = clamp(p.x, 0, right - minW); else right = clamp(p.x, left + minW, 1);
  rect = { x: left, y: top, w: right - left, h: bottom - top };
} else {
  // uchwyty naro≈ºne ‚Äì niezale≈ºna zmiana szer./wys. bez wymuszania aspektu
  if (drag.handle === 'nw') { left = clamp(p.x, 0, right - minW); top = clamp(p.y, 0, bottom - minH); }
  else if (drag.handle === 'ne') { right = clamp(p.x, left + minW, 1); top = clamp(p.y, 0, bottom - minH); }
  else if (drag.handle === 'sw') { left = clamp(p.x, 0, right - minW); bottom = clamp(p.y, top + minH, 1); }
  else if (drag.handle === 'se') { right = clamp(p.x, left + minW, 1); bottom = clamp(p.y, top + minH, 1); }
  rect = { x: left, y: top, w: right - left, h: bottom - top };
}
     }
     if (which === 'game') state.gameRect = rect; else state.cameraRect = rect;
     updateBothVisuals();
   });
   window.addEventListener('mouseup', ()=>{ 
     // Nie modyfikuj rozmiaru/ratio po puszczeniu myszy ‚Äì pozostaw dok≈Çadnie to, co ustawi≈Ç u≈ºytkownik
     drag = null; 
     validateAndUpdateVisuals();
   });
   window.addEventListener('resize', validateAndUpdateVisuals);
 
   // stara funkcja update usuni√Ñ‚Ñ¢ta - teraz u√Ö¬ºywamy validateAndUpdateVisuals()
 
     let ensureErrorMessage = null;
     async function pollEnsureStatus(totalHint){
       try {
         const r = await fetch('/api/ensure-cache/status', { cache: 'no-store' });
         if (!r.ok) throw new Error('status failed');
         const s = await r.json();
         const total = s.total || totalHint || 0;
         const done = s.done || 0;
         if (total > 0) {
           const pct = Math.max(0, Math.min(100, Math.round((done/total)*100)));
           dlBar.style.width = pct + '%';
           dlCount.textContent = `${done}/${total}`;
         } else {
           dlBar.style.width = '100%';
         }
         if (s.state === 'error') {
           ensureErrorMessage = s.error || s.message || 'B≈ÇƒÖd podczas pobierania';
           return true;
         }
         if (s.state === 'done' || (total && done >= total)) return true;
       } catch (e) {
         // zignoruj chwilowe b√Ö≈Ç√Ñ‚Ñ¢dy
       }
       return false;
     }
 
     async function ensureCacheWithProgress(totalHint){
       if (!clips || clips.length === 0) return;
       dlWrap.hidden = false;
       dlText.textContent = 'Pobieranie i generowanie prewek...';
       dlBar.style.width = '0%';
       dlCount.textContent = `0/${totalHint || clips.length}`;
       setInfo('Trwa przygotowywanie plik√≥w do podglƒÖdu...');
  
       ensureErrorMessage = null;
       const postPromise = fetch('/api/ensure-cache', { method: 'POST' })
         .then(r=>r.json())
         .catch(err=>{
           ensureErrorMessage = err.message;
         });
  
       let done = false;
       while (!done) {
         const sdone = await pollEnsureStatus(totalHint || clips.length);
         if (sdone) done = true; else await new Promise(res=>setTimeout(res, 1000));
       }
       await postPromise;
  
       if (ensureErrorMessage) {
         dlText.textContent = 'B≈ÇƒÖd';
         setInfo('B≈ÇƒÖd pobierania: ' + ensureErrorMessage, true);
         // Nie blokuj UI ‚Äì pozw√≥l u≈ºytkownikowi spr√≥bowaƒá odtwarzania lub ponowiƒá, ale schowaj pasek
         dlWrap.hidden = true;
         return;
       }
 
       dlText.textContent = 'Zako≈Ñczono';
       dlBar.style.width = '100%';
       dlWrap.hidden = true;
 
       setInfo('Gotowe. Mo≈ºesz odtwarzaƒá i kadrowaƒá klipy.');
     }
 
   document.getElementById('btn-save-crop').addEventListener('click', async ()=>{
     if (!active) { alert('Najpierw wybierz klip.'); return; }
     if (!state.gameRect || !state.cameraRect){ alert('Zaznacz obszary dla gry i kamerki.'); return; }
     try {
       const [r1, r2] = await Promise.all([
         fetch('/api/crop', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ clip_id: active.clip_id, rect: state.gameRect, kind: 'game' }) }),
         fetch('/api/crop', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ clip_id: active.clip_id, rect: state.cameraRect, kind: 'camera' }) })
       ]);
       if (!r1.ok) throw new Error(await r1.text());
       if (!r2.ok) throw new Error(await r2.text());
       setInfo('Zapisano kadry (gra i kamerka) dla ' + active.clip_id);
     } catch (e) {
       setInfo('B≈ÇƒÖd zapisu kadr√≥w: ' + e.message, true);
       alert('B≈ÇƒÖd zapisu kadr√≥w: ' + e.message);
     }
   });
 
     // Bootstrap wyboru z localStorage -> backend, potem auto-start ensure-cache, auto-select first
     (async function bootstrap(){
       try {
         let posted = false;
         const raw = localStorage.getItem('pendingSelection');
         if (raw) {
           const payload = JSON.parse(raw);
           if (payload && Array.isArray(payload.clips) && payload.clips.length) {
             setInfo('Zapisujƒô wyb√≥r klip√≥w...');
             const res = await fetch('/api/selection', {
               method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
             });
             if (res.ok) {
               localStorage.removeItem('pendingSelection');
               // zaktualizuj lokalny stan listy klip√≥w bez prze≈Çadowania
               clips = payload.clips;
               renderList();
               posted = true;
              setInfo(`Wybrano ${clips.length} klip√≥w.`);
             }
           }
         }
         if (!clips || clips.length === 0) {
           setInfo('Brak wybranych klip√≥w. Wr√≥ƒá do raportu i zaznacz klipy.', true);
           return;
         }
         // automatycznie zacznij pobieranie + prewki zanim odtworzymy pierwszy klip
         await ensureCacheWithProgress(clips.length);
         // auto-select pierwszego po przygotowaniu
         selectClip(clips[0]);
       } catch(e) {
         console.error(e);
         setInfo('WystƒÖpi≈Ç b≈ÇƒÖd inicjalizacji edytora: ' + e.message, true);
       }
     })();
  (function(){
    try{
      const cleanTail = ()=>{
        const body = document.body;
        let n = body && body.lastChild;
        let guard = 0;
        while(n && guard++ < 5000){
          if (n.nodeType === Node.TEXT_NODE && /^[\s}\)]+$/.test(n.textContent||'')){
            const prev = n.previousSibling; body.removeChild(n); n = prev; continue;
          }
          n = n.previousSibling;
        }
      };
      if (document.readyState === 'loading'){
        document.addEventListener('DOMContentLoaded', cleanTail, { once: true });
      } else { cleanTail(); }
    }catch(e){}
  })();
  </script>

  <!-- Panel podglƒÖdu 9:16 i trimowania -->
  <div style="margin-top:16px; display:flex; gap:24px; align-items:flex-start; flex-wrap:wrap;">
    <div>
      <div style="font-weight:600; margin-bottom:6px;">PodglƒÖd 9:16</div>
      <canvas id="final-preview" width="270" height="480" style="background:#000; border:1px solid #999; border-radius:6px; display:block;"></canvas>
    </div>
    <div style="min-width:260px;">
      <div style="font-weight:600; margin-bottom:6px;">Trim</div>
      <div class="timebar"><span class="time-label" id="time-label">0:00 / 0:00</span><input id="time-slider" type="range" min="0" value="0" step="0.01"></div>
      <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:6px;">
        <label>Start (s): <input id="trim-start" type="number" step="0.1" min="0" style="width:90px"></label>
        <button id="btn-set-start" class="btn" type="button">Ustaw = czas</button>
      </div>
      <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:6px;">
        <label>Koniec (s): <input id="trim-end" type="number" step="0.1" min="0" style="width:90px"></label>
        <button id="btn-set-end" class="btn" type="button">Ustaw = czas</button>
      </div>
      <div style="margin-top:10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
        <button id="btn-transcribe" class="btn" type="button">üìù Transkrybuj SRT</button>
        <span id="srt-status" style="color:#555"></span>
        <a id="srt-link" href="#" target="_blank" style="display:none;">Pobierz SRT</a>
      </div>
      <div style="margin-top:10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
        <button id="btn-render" class="btn" type="button">üé¨ Renderuj 1080x1920</button>
        <label style="display:flex; align-items:center; gap:6px;">
          <input type="checkbox" id="include-subtitles" checked>
          <span>Wypal napisy (karaoke/SRT)</span>
        </label>
        <a id="render-link" href="#" target="_blank" style="display:none;">Pobierz wynik</a>
        <button id="btn-render-retry" class="btn" type="button" style="display:none;">üîÅ Pon√≥w renderowanie</button>
        <button id="btn-render-error" class="btn" type="button" style="display:none;">‚ÑπÔ∏è Poka≈º b≈ÇƒÖd</button>
        <pre id="render-error-details" style="display:none; max-width:480px; white-space:pre-wrap; background:#fff3f3; border:1px solid #f3caca; padding:8px; border-radius:6px;"></pre>
        <button id="btn-publish" class="btn" type="button" style="display:none;">üì£ Opublikuj‚Ä¶</button>
        <div id="publish-panel" style="display:none; gap:8px; align-items:center; flex-wrap:wrap; margin-top:6px; background:#f6f6f6; padding:8px; border-radius:6px;">
          <label style="display:flex; align-items:center; gap:6px;">
            <input type="radio" name="publish_mode" id="pub-now" value="now" checked>
            <span>Publikuj teraz</span>
          </label>
          <label style="display:flex; align-items:center; gap:6px;">
            <input type="radio" name="publish_mode" id="pub-sched" value="schedule">
            <span>Zaplanuj publikacjƒô</span>
          </label>
          <div id="pub-accounts" style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
            <span style="color:#555;">Konta:</span>
            <span id="pub-accounts-loading" style="color:#888;">≈Åadowanie kont‚Ä¶</span>
          </div>
          <input type="datetime-local" id="pub-time" style="display:none;" />
          <input type="text" id="pub-caption" placeholder="Podpis posta (opcjonalny)" style="min-width:260px;" />
          <div style="display:flex; gap:8px; align-items:flex-start; flex-wrap:wrap; margin-top:6px;">
            <input type="text" id="pub-tag-groups" placeholder="Grupy tag√≥w (np. twitch, merghani)" style="min-width:260px;" />
            <div id="pub-tag-groups-suggest" class="suggest-box" style="display:none;"></div>
            <div id="pub-tag-groups-selected" class="tag-list" style="min-width:260px;"></div>
          </div>
          <button id="btn-publish-confirm" class="btn" type="button">Wy≈õlij</button>
          <span id="publish-status" style="color:#555"></span>
        </div>
        <span id="karaoke-status" style="color:#555; display:none;">Karaoke: ‚Äî</span>
      </div>
    </div>
  </div>

  <script>
  const previewCanvas = document.getElementById('final-preview');
  const ctxPrev = previewCanvas.getContext('2d');
  const trimStartEl = document.getElementById('trim-start');
  const trimEndEl = document.getElementById('trim-end');
  const btnSetStart = document.getElementById('btn-set-start');
  const btnSetEnd = document.getElementById('btn-set-end');
  const btnRender = document.getElementById('btn-render');
  const renderLink = document.getElementById('render-link');
  const btnRenderRetry = document.getElementById('btn-render-retry');
  const btnRenderError = document.getElementById('btn-render-error');
  const renderErrorDetails = document.getElementById('render-error-details');
  const karaokeStatus = document.getElementById('karaoke-status');
  const includeSubtitlesEl = document.getElementById('include-subtitles');
  const timeSlider = document.getElementById('time-slider');
  const timeLabel = document.getElementById('time-label');
  let lastRenderPayload = null;
  let lastRenderResponse = null;

  btnSetStart.addEventListener('click', ()=>{ if (video.duration){ trimStartEl.value = video.currentTime.toFixed(2); } });
  btnSetEnd.addEventListener('click', ()=>{ if (video.duration){ trimEndEl.value = video.currentTime.toFixed(2); } });

  function fmtTime(t){ if (!isFinite(t) || t < 0) return '0:00'; const m = Math.floor(t/60); const s = Math.floor(t%60).toString().padStart(2,'0'); return `${m}:${s}`; }
  function updateTimeLabel(){ const cur = isFinite(video.currentTime) ? video.currentTime : 0; const dur = isFinite(video.duration) ? video.duration : 0; timeLabel.textContent = `${fmtTime(cur)} / ${fmtTime(dur)}`; }
  if (timeSlider) {
    video.addEventListener('loadedmetadata', ()=>{ if (isFinite(video.duration)) { timeSlider.max = video.duration.toFixed(2); timeSlider.value = 0; updateTimeLabel(); } });
    video.addEventListener('timeupdate', ()=>{ if (isFinite(video.currentTime)) { timeSlider.value = video.currentTime; updateTimeLabel(); } });
    timeSlider.addEventListener('input', ()=>{ if (isFinite(video.duration)) { const t = parseFloat(timeSlider.value); if (isFinite(t)) video.currentTime = t; } });
  }

  // Przenie≈õ panel podglƒÖdu/trim na prawƒÖ kolumnƒô obok edytora
  (function(){ const side = document.getElementById('side-preview'); const panel = document.getElementById('preview-trim-panel'); if (side && panel) { side.appendChild(panel); panel.style.marginTop = '0'; panel.style.display = 'block'; } })();

  function drawPreview(){
    const w = previewCanvas.width, h = previewCanvas.height;
    ctxPrev.fillStyle = '#000';
    ctxPrev.fillRect(0,0,w,h);
    if (!video.videoWidth || !state.gameRect) return;
    const vw = video.videoWidth, vh = video.videoHeight;
    if (state.singleFrame){
      // T≈Ço: ten sam klip mocno powiƒôkszony i rozmyty, cover ca≈Çego canvasu
      (function(){
        const r = state.gameRect; let sx = Math.floor(r.x*vw), sy = Math.floor(r.y*vh);
        let sw = Math.floor(r.w*vw), sh = Math.floor(r.h*vh);
        sw = Math.max(1, Math.min(vw - sx, sw));
        sh = Math.max(1, Math.min(vh - sy, sh));
        if (sw<=0||sh<=0) return;
        const A = w/h, a = sw/sh; let tw, th;
        if (a > A){ th = h; tw = Math.ceil(h*a); } else { tw = w; th = Math.ceil(w/a); }
        const ox = Math.floor((w - tw)/2), oy = Math.floor((h - th)/2);
        ctxPrev.save();
        ctxPrev.filter = 'blur(12px) brightness(0.85)';
        ctxPrev.drawImage(video, sx, sy, sw, sh, ox, oy, tw, th);
        ctxPrev.restore();
      })();
      // Panel 21:9 o zadanej wysoko≈õci
      let panelH = Math.round(h * state.singleHeightRatio);
      if (panelH % 2) panelH += 1; panelH = Math.max(2, Math.min(h, panelH));
      const panelY = Math.floor((h - panelH)/2);
      const dw = w, dh = panelH;
      (function(){
        const r = state.gameRect; let sx = Math.floor(r.x*vw), sy = Math.floor(r.y*vh);
        let sw = Math.floor(r.w*vw), sh = Math.floor(r.h*vh);
        sw = Math.max(1, Math.min(vw - sx, sw));
        sh = Math.max(1, Math.min(vh - sy, sh));
        if (sw<=0||sh<=0) return;
        const a = sw/sh, A = dw/dh; let tw, th;
        if (a > A){ th = dh; tw = Math.ceil(dh*a); } else { tw = dw; th = Math.ceil(dw/a); }
        const ox = Math.floor((dw - tw)/2); const oy = Math.floor(panelY + (dh - th)/2);
        ctxPrev.save(); ctxPrev.beginPath(); ctxPrev.rect(0, panelY, dw, dh); ctxPrev.clip();
        ctxPrev.drawImage(video, sx, sy, sw, sh, ox, oy, tw, th);
        ctxPrev.restore();
      })();
      return;
    }
   let topH, botH;
   if (state.autoSplit){
     const aCam = Math.max(1e-6, state.cameraRect.w / Math.max(1e-6, state.cameraRect.h));
     const aGame = Math.max(1e-6, state.gameRect.w / Math.max(1e-6, state.gameRect.h));
     const pCam = 1 / aCam, pGame = 1 / aGame;
     const sum = pCam + pGame;
     topH = Math.max(2, Math.round(h * (pCam / sum)));
     botH = Math.max(2, h - topH);
   } else {
     const g = state.gameRatio, c = 1 - g;
     topH = Math.max(2, Math.round(h * c));
     botH = Math.max(2, h - topH);
   }
   // enforce even heights (synchronizacja z ffmpeg)
   if (topH % 2) topH += 1;
   if (botH % 2) botH -= 1;
   if (botH <= 0) botH = 2;
   if (topH + botH !== h) botH = h - topH;

    // camera (top) i game (bottom) bez pas√≥w ‚Äì wype≈Çnienie (cover)
    function drawCover(r, dx, dy, dw, dh, relief = 1.0){
      let sx = Math.floor(r.x * vw), sy = Math.floor(r.y * vh);
      let sw = Math.floor(r.w * vw), sh = Math.floor(r.h * vh);
      sw = Math.max(1, Math.min(vw - sx, sw));
      sh = Math.max(1, Math.min(vh - sy, sh));
      if (sw <= 0 || sh <= 0) return;
      const a = sw / sh, A = dw / dh; // a: aspekt ≈∫r√≥d≈Ça, A: aspekt celu
      let tw, th; // rozmiar docelowy (mo≈ºe wyjechaƒá poza ramkƒô; obetniemy klipem)
      if (a > A) {
        // ≈∫r√≥d≈Ço szersze ni≈º cel ‚Üí dopasuj wysoko≈õƒá; szeroko≈õƒá mo≈ºe wyj≈õƒá poza docelowƒÖ
        th = Math.ceil(dh * relief);
        tw = Math.ceil((dh * a) * relief);
      } else {
        // ≈∫r√≥d≈Ço wƒô≈ºsze ‚Üí dopasuj szeroko≈õƒá; wysoko≈õƒá mo≈ºe wyj≈õƒá poza docelowƒÖ
        tw = Math.ceil(dw * relief);
        th = Math.ceil((dw / a) * relief);
      }
      const ox = Math.floor(dx + (dw - tw)/2);
      const oy = Math.floor(dy + (dh - th)/2);
      // ogranicz rysowanie do obszaru [dx,dy,dw,dh], aby nic nie zachodzi≈Ço na sƒÖsiedniƒÖ sekcjƒô
      ctxPrev.save();
      ctxPrev.beginPath();
      ctxPrev.rect(dx, dy, dw, dh);
      ctxPrev.clip();
      ctxPrev.drawImage(video, sx, sy, sw, sh, ox, oy, tw, th);
      ctxPrev.restore();
    }

    // camera (top) i game (bottom) ‚Äì cover strict (bez pad√≥w/soften)
    drawCover(state.cameraRect, 0, 0, w, topH, 1.0);
    drawCover(state.gameRect, 0, topH, w, botH, 1.0);
  }
  function previewLoop(){
    try{ drawPreview(); }catch(e){}
    requestAnimationFrame(previewLoop);
  }
  previewLoop();

  function makeRenderPayload(){
    const start = parseFloat(trimStartEl.value);
    const end = parseFloat(trimEndEl.value);
    return {
      clip_id: active.clip_id,
      game: state.gameRect,
      camera: state.cameraRect || null,
      game_ratio: state.gameRatio,
      auto_split: !!state.autoSplit,
      single_frame: !!state.singleFrame,
      single_height_ratio: state.singleHeightRatio,
      fit_mode: 'cover',
      start: isFinite(start) ? start : null,
      end: isFinite(end) ? end : null,
      include_subtitles: includeSubtitlesEl ? !!includeSubtitlesEl.checked : true
    };
  }
  function pollRenderUntilFinish(clipId){
    let attempts = 0;
    const maxAttempts = 180; // ~6 min przy 2s
    const intervalMs = 2000;
    const tick = async ()=>{
      attempts++;
      try{
        const r = await fetch(`/api/render/status?clip_id=${encodeURIComponent(clipId)}`, { cache:'no-store' });
        const s = await r.json().catch(()=>({}));
        if (s && s.state === 'done' && s.url){
          renderLink.href = s.url; renderLink.style.display = 'inline-block';
          const btnPublish = document.getElementById('btn-publish'); if (btnPublish) btnPublish.style.display = 'inline-block';
          if (karaokeStatus){ karaokeStatus.style.display = 'inline-block'; karaokeStatus.textContent = `Karaoke: ${s.karaoke || 'brak'}`; }
          setInfo('Render zako≈Ñczony.');
          if (btnRenderRetry) btnRenderRetry.style.display = 'none';
          if (btnRenderError) btnRenderError.style.display = 'none';
          if (renderErrorDetails) renderErrorDetails.style.display = 'none';
          return; // stop polling
        }
        if (s && s.state === 'error'){
          setInfo('B≈ÇƒÖd renderu: ' + (s.error || ''));
          if (btnRenderRetry) btnRenderRetry.style.display = 'inline-block';
          if (btnRenderError) btnRenderError.style.display = 'inline-block';
          if (renderErrorDetails){ renderErrorDetails.textContent = JSON.stringify(s, null, 2); }
          return; // stop polling
        }
        // running/idle ‚Üí continue
      }catch(e){ /* ignore and continue */ }
      if (attempts < maxAttempts){
        setTimeout(tick, intervalMs);
      } else {
        setInfo('Timeout oczekiwania na zako≈Ñczenie renderu.', true);
        if (btnRenderRetry) btnRenderRetry.style.display = 'inline-block';
      }
    };
    tick();
  }
  async function performRender(payload){
    setInfo('Render w toku...');
    renderLink.style.display = 'none';
    if (karaokeStatus){ karaokeStatus.style.display = 'inline-block'; karaokeStatus.textContent = 'Karaoke: (w toku...)'; }
    // reset error UI
    if (btnRenderRetry) btnRenderRetry.style.display = 'none';
    if (btnRenderError) btnRenderError.style.display = 'none';
    if (renderErrorDetails){ renderErrorDetails.style.display = 'none'; renderErrorDetails.textContent = ''; }
    lastRenderPayload = payload;
    try{
      const r = await fetch('/api/render', { method:'POST', headers:{'Content-Type':'application/json'}, cache:'no-store', body: JSON.stringify(payload)});
      let j;
      try {
        j = await r.json();
      } catch (parseErr) {
        const txt = await r.text().catch(()=> '');
        j = { ok:false, error: 'Invalid JSON response', status: r.status, content_type: (r.headers && r.headers.get ? r.headers.get('content-type') : undefined), text_snippet: (txt||'').slice(0, 400) };
      }
      lastRenderResponse = j;
      if (!j.ok){
        setInfo('B≈ÇƒÖd renderu: ' + (j.error || ''));
        if (karaokeStatus){ karaokeStatus.textContent = 'Karaoke: b≈ÇƒÖd'; }
        if (btnRenderRetry) btnRenderRetry.style.display = 'inline-block';
        if (btnRenderError) btnRenderError.style.display = 'inline-block';
        if (renderErrorDetails){ renderErrorDetails.textContent = JSON.stringify(j, null, 2); }
        // fallback: je≈õli tunel/edge zwraca 524/504 (HTML), rozpocznij polling statusu renderu
        const isEdgeTimeout = (String(j.status)==='524' || String(j.status)==='504' || (j.content_type||'').includes('text/html'));
        if (isEdgeTimeout && active && active.clip_id){
          setInfo('Render prawdopodobnie trwa w tle ‚Äî sprawdzam status‚Ä¶');
          if (karaokeStatus){ karaokeStatus.style.display = 'inline-block'; karaokeStatus.textContent = 'Karaoke: (w toku...)'; }
          pollRenderUntilFinish(active.clip_id);
        }
        return;
      }
      renderLink.href = j.url; renderLink.style.display = 'inline-block';
      const btnPublish = document.getElementById('btn-publish'); if (btnPublish) btnPublish.style.display = 'inline-block';
      const kinfo = (j.karaoke ? ` (karaoke: ${j.karaoke})` : '');
      if (karaokeStatus){ karaokeStatus.style.display = 'inline-block'; karaokeStatus.textContent = `Karaoke: ${j.karaoke || 'brak'}`; }
      setInfo('Render zako≈Ñczony.' + kinfo);
      // success ‚Üí hide error helpers
      if (btnRenderRetry) btnRenderRetry.style.display = 'none';
      if (btnRenderError) btnRenderError.style.display = 'none';
      if (renderErrorDetails) renderErrorDetails.style.display = 'none';
    }catch(e){
      setInfo('B≈ÇƒÖd renderu: ' + e.message, true);
      if (karaokeStatus){ karaokeStatus.textContent = 'Karaoke: b≈ÇƒÖd'; }
      if (btnRenderRetry) btnRenderRetry.style.display = 'inline-block';
      if (btnRenderError) btnRenderError.style.display = 'inline-block';
      if (renderErrorDetails){ renderErrorDetails.textContent = String(e && e.stack ? e.stack : e.message || e); }
    }
  }
  btnRender.addEventListener('click', async ()=>{
    if (!active){ alert('Najpierw wybierz klip.'); return; }
    if (!state.gameRect || (!state.singleFrame && !state.cameraRect)){ alert('Najpierw zaznacz wymagane kadry.'); return; }
    await performRender(makeRenderPayload());
  });
  if (btnRenderRetry){
    btnRenderRetry.addEventListener('click', async ()=>{
      if (!lastRenderPayload){ alert('Brak poprzednich parametr√≥w renderu.'); return; }
      const go = confirm('Ponowiƒá renderowanie tego klipu z tymi samymi parametrami?');
      if (!go) return;
      btnRenderRetry.disabled = true;
      try{ await performRender(lastRenderPayload); } finally { btnRenderRetry.disabled = false; }
    });
  }
  if (btnRenderError && renderErrorDetails){
    btnRenderError.addEventListener('click', ()=>{
      const vis = renderErrorDetails.style.display !== 'none';
      renderErrorDetails.style.display = vis ? 'none' : 'block';
    });
  }
  </script>

  <script>
  (function(){
    const btnTranscribe = document.getElementById('btn-transcribe');
    const srtStatus = document.getElementById('srt-status');
    const srtLink = document.getElementById('srt-link');
    function resetSrtUi(){ srtStatus.textContent = ''; srtLink.style.display = 'none'; srtLink.href = '#'; }
    async function pollTranscribe(clip_id){
      try{
        const r = await fetch(`/api/transcribe/status?clip_id=${encodeURIComponent(clip_id)}`, { cache:'no-store' });
        if (!r.ok) throw new Error('status failed');
        const j = await r.json();
        if (j.state === 'done' && j.url){ srtStatus.textContent = 'Gotowe'; srtLink.href = j.url; srtLink.style.display = 'inline-block'; return true; }
        if (j.state === 'error'){ srtStatus.textContent = 'B≈ÇƒÖd: ' + (j.error || ''); return true; }
        if (j.state === 'running'){ srtStatus.textContent = 'Trwa transkrypcja...'; return false; }
      }catch(e){ /* ignore transient */ }
      return false;
    }
    async function startTranscribe(){
      if (!window.active){ alert('Najpierw wybierz klip.'); return; }
      resetSrtUi(); srtStatus.textContent = 'Uruchamianie...';
      try{
        const r = await fetch('/api/transcribe', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ clip_id: window.active.clip_id }) });
        const j = await r.json();
        if (!r.ok || j.ok === false){ srtStatus.textContent = 'B≈ÇƒÖd: ' + (j.error || ''); return; }
        if (j.state === 'done' && j.url){ srtStatus.textContent = 'Gotowe'; srtLink.href = j.url; srtLink.style.display = 'inline-block'; return; }
        srtStatus.textContent = 'Trwa transkrypcja...';
        let done = false;
        while(!done){
          done = await pollTranscribe(window.active.clip_id);
          if (!done) await new Promise(res=>setTimeout(res, 1500));
        }
      }catch(e){ srtStatus.textContent = 'B≈ÇƒÖd: ' + e.message; }
    }
    if (btnTranscribe) btnTranscribe.addEventListener('click', startTranscribe);

    const _origSelectClip = window.selectClip;
    window.selectClip = async function(c){
      await _origSelectClip(c);
      resetSrtUi();
      // Resetuj status karaoke po zmianie klipu
      try {
        const ks = document.getElementById('karaoke-status');
        if (ks){ ks.style.display = 'none'; ks.textContent = 'Karaoke: ‚Äî'; }
      } catch(e){}
      if (window.active && window.active.clip_id){ pollTranscribe(window.active.clip_id); }
    };
    window.resetSrtUi = resetSrtUi;
    window.pollTranscribe = pollTranscribe;
  })();
  </script>

  <script>
  (function(){
    const btnPublish = document.getElementById('btn-publish');
    const publishPanel = document.getElementById('publish-panel');
    const pubNow = document.getElementById('pub-now');
    const pubSched = document.getElementById('pub-sched');
    const pubTime = document.getElementById('pub-time');
    const pubCaption = document.getElementById('pub-caption');
    const pubTagGroupsInput = document.getElementById('pub-tag-groups');
    const pubTagGroupsSuggest = document.getElementById('pub-tag-groups-suggest');
    const pubTagGroupsSelected = document.getElementById('pub-tag-groups-selected');
    const btnPublishConfirm = document.getElementById('btn-publish-confirm');
    const publishStatus = document.getElementById('publish-status');
    const renderLink = document.getElementById('render-link');
    const pubAccounts = document.getElementById('pub-accounts');
    const pubAccountsLoading = document.getElementById('pub-accounts-loading');
    // --- Grupy tag√≥w ---
    window.tagGroups = {};
    window.selectedGroups = new Set();
    function renderSelectedGroups(){
      if (!pubTagGroupsSelected) return;
      pubTagGroupsSelected.innerHTML = '';
      if (selectedGroups.size === 0){
        pubTagGroupsSelected.innerHTML = '<span style="color:#888;">Brak wybranych grup</span>';
        return;
      }
      Array.from(selectedGroups).forEach(name=>{
        const el = document.createElement('span');
        el.className = 'tag';
        el.innerHTML = `<span>${name}</span> <button class="remove" title="Usu≈Ñ">‚úñ</button>`;
        const rm = el.querySelector('.remove');
        if (rm) rm.addEventListener('click', ()=>{ selectedGroups.delete(name); renderSelectedGroups(); });
        pubTagGroupsSelected.appendChild(el);
      });
    }
    function hideSuggest(){ if (pubTagGroupsSuggest){ pubTagGroupsSuggest.style.display='none'; pubTagGroupsSuggest.innerHTML=''; } }
    function showSuggest(items){
      if (!items.length){ hideSuggest(); return; }
      if (!pubTagGroupsInput || !pubTagGroupsSuggest) return;
      pubTagGroupsSuggest.style.display = 'block';
      const rect = pubTagGroupsInput.getBoundingClientRect();
      pubTagGroupsSuggest.style.position = 'absolute';
      pubTagGroupsSuggest.style.top = (window.scrollY + rect.bottom + 4) + 'px';
      pubTagGroupsSuggest.style.left = (window.scrollX + rect.left) + 'px';
      pubTagGroupsSuggest.style.minWidth = rect.width + 'px';
      pubTagGroupsSuggest.innerHTML = items.map(({name,tags})=>`<div class="suggest-item" data-name="${name}"><span>${name}</span><span class="platform">${(tags||[]).length} tag√≥w</span></div>`).join('');
      pubTagGroupsSuggest.querySelectorAll('.suggest-item').forEach(el=>{
        el.addEventListener('click', ()=>{
          const g = el.dataset.name;
          selectedGroups.add(g);
          if (pubTagGroupsInput) pubTagGroupsInput.value = g;
          hideSuggest();
          renderSelectedGroups();
          if (pubTagGroupsInput) pubTagGroupsInput.focus();
        });
      });
    }
    async function loadTagGroups(){
      try{
        const r = await fetch('/api/streamers-prefs', { cache:'no-store' });
        const j = await r.json();
        tagGroups = (j && typeof j.tag_groups==='object') ? j.tag_groups : {};
      }catch{/* ignore */}
    }
    if (pubTagGroupsInput){
      pubTagGroupsInput.addEventListener('input', ()=>{
        const q = (pubTagGroupsInput.value||'').trim().toLowerCase();
        if (!q){ hideSuggest(); return; }
        const entries = Object.entries(tagGroups||{}).map(([name,tags])=>({name, tags}));
        const matched = entries.filter(e=> e.name.includes(q)).slice(0, 10);
        showSuggest(matched);
      });
      pubTagGroupsInput.addEventListener('blur', ()=> setTimeout(hideSuggest, 120));
    }

    async function loadPublerAccounts(){
      if (!pubAccounts || pubAccounts.dataset.loaded === '1') return;
      try{
        if (pubAccountsLoading) pubAccountsLoading.style.display = 'inline';
        // Try using default workspace from .env first
        let res = await fetch('/api/publer/accounts', { cache:'no-store' });
        let j = await res.json().catch(()=>({}));
        if (!res.ok || j.ok === false){
          // Fallback: get first workspace, then accounts
          const ws = await fetch('/api/publer/workspaces', { cache:'no-store' });
          const wj = await ws.json().catch(()=>({}));
          let workspaces = (wj && wj.data && (wj.data.data || wj.data)) || [];
          if (!Array.isArray(workspaces) && workspaces && workspaces.data) workspaces = workspaces.data;
          const firstWs = Array.isArray(workspaces) && workspaces.length ? workspaces[0] : null;
          if (!firstWs || !firstWs.id){ throw new Error('Brak workspace w Publer.'); }
          const url = `/api/publer/accounts?workspace_id=${encodeURIComponent(firstWs.id)}`;
          res = await fetch(url, { cache:'no-store' });
          j = await res.json().catch(()=>({}));
          if (!res.ok || j.ok === false){ throw new Error(j && (j.error || j.status_code) || 'Nie uda≈Ço siƒô pobraƒá kont.'); }
        }
        let accounts = (j && j.data && (j.data.data || j.data)) || [];
        if (!Array.isArray(accounts) && accounts && accounts.data) accounts = accounts.data;
        // Render checkboxes, default all checked
        if (pubAccountsLoading) pubAccountsLoading.remove();
        const title = document.createElement('span'); title.style.color = '#555'; title.textContent = 'Konta:';
        if (!pubAccounts.querySelector('span')) pubAccounts.prepend(title);
        accounts.forEach(acc => {
          const accId = acc.id || acc._id || acc.account_id;
          if (!accId) return;
          const label = document.createElement('label');
          label.style.display = 'flex';
          label.style.alignItems = 'center';
          label.style.gap = '6px';
          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.name = 'pub-acct';
          cb.value = accId;
          cb.checked = true; // default: publish to all
          const name = acc.username || acc.name || acc.title || '';
          const provider = (acc.provider || acc.type || '').toString();
          const text = provider ? `${name} (${provider})` : name || accId;
          const span = document.createElement('span'); span.textContent = text;
          label.appendChild(cb); label.appendChild(span);
          pubAccounts.appendChild(label);
        });
        pubAccounts.dataset.loaded = '1';
      }catch(e){
        if (pubAccountsLoading) pubAccountsLoading.textContent = 'Nie uda≈Ço siƒô za≈Çadowaƒá kont: ' + e.message;
      }
    }

    btnPublish?.addEventListener('click', async ()=>{
      if (!window.active){ alert('Najpierw wybierz klip.'); return; }
      const willShow = (publishPanel.style.display === 'none' || publishPanel.style.display === '');
      publishPanel.style.display = willShow ? 'flex' : 'none';
      publishStatus.textContent = '';
      if (willShow){ await loadPublerAccounts(); await loadTagGroups(); renderSelectedGroups(); }
    });
    pubNow?.addEventListener('change', ()=>{ if (pubNow.checked){ pubTime.style.display = 'none'; }});
    pubSched?.addEventListener('change', ()=>{ if (pubSched.checked){ pubTime.style.display = 'inline-block'; }});
    btnPublishConfirm?.addEventListener('click', async ()=>{
      try{
        if (!window.active){ alert('Najpierw wybierz klip.'); return; }
        if (!renderLink.href || renderLink.style.display === 'none'){
          alert('Najpierw wyrenderuj klip.'); return;
        }
        publishStatus.textContent = 'Wysy≈Çam‚Ä¶';
        const clip_id = window.active.clip_id;
        // Wklej tagi z wybranych grup do podpisu (deduplikacja)
        let caption = pubCaption.value || '';
        const existing = new Set((caption.match(/(^|\s)#\w+/g)||[]).map(s=>s.trim().toLowerCase()));
        const addTags = [];
        Array.from(selectedGroups).forEach(name=>{
          const tags = tagGroups[name] || [];
          tags.forEach(t=>{
            const norm = (t||'').trim();
            if (!norm) return;
            const withHash = norm.startsWith('#') ? norm : ('#' + norm);
            const key = withHash.toLowerCase();
            if (!existing.has(key)) { existing.add(key); addTags.push(withHash); }
          });
        });
        if (addTags.length > 0){
          const sep = caption ? ' ' : '';
          caption = caption + sep + addTags.join(' ');
          pubCaption.value = caption; // uaktualnij widocznie
        }
        const body = { caption: caption || undefined };
        if (pubSched.checked){
          const dt = pubTime.value; // yyyy-MM-ddTHH:mm
          if (!dt){ publishStatus.textContent = 'Wybierz datƒô i czas.'; return; }
          const local = new Date(dt);
          const iso = new Date(local.getTime() - (local.getTimezoneOffset()*60000)).toISOString().slice(0,19) + 'Z';
          body.publish_now = false;
          body.scheduled_at = iso;
        } else {
          body.publish_now = true;
        }
        // gather selected accounts (default all)
        if (pubAccounts){
          const selected = Array.from(pubAccounts.querySelectorAll('input[name="pub-acct"]:checked')).map(el=>el.value);
          if (selected.length > 0){ body.publer_account_ids = selected; }
        }
        const r = await fetch(`/publish/${encodeURIComponent(clip_id)}`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)});
        const j = await r.json();
        if (!r.ok || j.ok === false){ publishStatus.textContent = 'B≈ÇƒÖd: ' + (j.error || r.statusText); return; }
        if (j.dry_run){ publishStatus.textContent = 'OK (dry-run). Dodaj PUBLER_* do .env aby publikowaƒá.'; }
        else if (j.published){ publishStatus.textContent = 'Opublikowano!'; }
        else { publishStatus.textContent = 'Wys≈Çano. Sprawd≈∫ logi.'; }
      }catch(e){ publishStatus.textContent = 'B≈ÇƒÖd: ' + e.message; }
    });
    // Usuwanie zbƒôdnych wƒôz≈Ç√≥w tekstowych na ko≈Ñcu dokumentu (np. same nawiasy)
    try {
      Array.from(document.body.childNodes).forEach(n=>{
        if (n.nodeType === Node.TEXT_NODE){
          const s = n.textContent || '';
          if (/^[\s}]+$/.test(s)) n.remove();
        }
      });
      // Uruchom ponownie po pe≈Çnym parsowaniu dokumentu, by z≈Çapaƒá p√≥≈∫niej wstawione wƒôz≈Çy
      document.addEventListener('DOMContentLoaded', ()=>{
        Array.from(document.body.childNodes).forEach(n=>{
          if (n.nodeType === Node.TEXT_NODE){
            const s = n.textContent || '';
            if (/^[\s}]+$/.test(s)) n.remove();
          }
        });
      }, { once:true });
      // Dodatkowo obserwuj p√≥≈∫niejsze wstawienia i natychmiast usuwaj artefakty
      const obs = new MutationObserver(muts=>{
        try{
          muts.forEach(m=>{
            (m.addedNodes || []).forEach(n=>{
              if (n.nodeType === Node.TEXT_NODE){
                const s = n.textContent || '';
                if (/^[\s}]+$/.test(s)) n.remove();
              } else if (n.nodeType === Node.ELEMENT_NODE){
                Array.from(n.childNodes).forEach(c=>{
                  if (c.nodeType === Node.TEXT_NODE){
                    const s = c.textContent || '';
                    if (/^[\s}]+$/.test(s)) c.remove();
                  }
                });
              }
            });
          });
        }catch(e){}
      });
      obs.observe(document.body, { childList: true, subtree: true });
    } catch (e) {}
  })();
  </script>

  <pre style="display:none">
  </pre>
  <script>
    (function(){
      try{
        const pres = document.querySelectorAll('pre[style*="display:none"]');
        const pre = pres[pres.length-1];
        if (pre){
          let n = pre.nextSibling;
          while(n){
            const next = n.nextSibling;
            if (n.nodeType === Node.TEXT_NODE){ n.textContent = ''; }
            else if (n.nodeType === Node.ELEMENT_NODE){ n.style.display = 'none'; }
            n = next;
          }
        }
      }catch(e){/* ignore */}
    })();
  </script>  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  </body>
  </html>
