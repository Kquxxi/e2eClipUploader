<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8">
  <title>Panel Twitch Clips</title>
  <link rel="stylesheet" href="/static/style.css?v={{ cache_buster }}">
</head>
<body>
  <div class="container">
    <header>
      <h1>Panel Twitch Clips</h1>
      <div class="actions">
        <button id="btn-update" class="btn">Od≈õwie≈º streamer√≥w twitch</button>
        <button id="btn-report" class="btn">Generuj raport Twitch</button>
        <button id="btn-kick" class="btn">Generuj raport Kick</button>
        <a href="/admin" id="admin-link" class="btn" title="Preferencje streamer√≥w">‚öôÔ∏è Panel admina</a>
        <span id="spinner" style="display:none;margin-left:8px;">‚è≥</span>
      </div>
      <div id="status" class="status"></div>
    <div id="progress-counter" class="status" style="display:none"></div>
    <div id="auto-refresh" class="status" style="margin-top:6px;">
      üîÅ Auto-od≈õwie≈ºanie za: <span id="refresh-timer">--:--</span>
      <div id="twitch-progress-bar" class="progress-bar" style="margin-top:6px; display:none;">
        <div id="progress-fill" class="progress-fill" style="width:0%"></div>
      </div>
    </div>
    <!-- Kick: progres analogiczny do Twitch -->
    <div id="kick-progress" class="status" style="margin-top:6px; display:none;">
      üü¢ Kick: postƒôp: <span id="progress-counter-kick">‚Äî</span>
      <div id="kick-progress-bar" class="progress-bar" style="margin-top:6px; display:none;">
        <div id="progress-fill-kick" class="progress-fill" style="width:0%"></div>
      </div>
    </div>
    </header>

    <div id="view-controls" class="subactions" style="margin:12px 0;">
      <button id="btn-hide-viewed" class="btn">Ukryj obejrzane</button>
      <span id="global-count" class="hint"></span>
    </div>

    <!-- Globalny pasek edytora: zawsze widoczny niezale≈ºnie od raportu -->
    <div id="global-editor-fixedbar" class="fixed-editor-bar" style="display:flex;">
      <button id="proceed-editor-fixed" class="btn" disabled>‚û°Ô∏è Dalej do edytora</button>
      <button id="view-saved-fixed" class="btn">üëÅÔ∏è Poka≈º zapisane</button>
    </div>

    <main>
<section id="raport-container" style="display:none;"></section>
<!-- Sta≈Çy pasek edytora na dole: dwa przyciski g≈Ç√≥wne -->
<div id="fallback-editor-controls" style="position:fixed; left:0; right:0; bottom:0; display:flex; gap:8px; padding:8px; background:rgba(20,20,24,0.9); border-top:1px solid #333; justify-content:center; z-index:1000;">
  <button id="fallback-proceed-editor" class="btn" title="Przejd≈∫ do edytora z zapisanymi">‚ûï Dodaj do edytora</button>
  <button id="fallback-view-saved" class="btn" title="Poka≈º/Ukryj zapisane">üìå Poka≈º zapisane</button>
</div>
<!-- Overlay zapisanych klip√≥w -->
<div id="saved-clips-panel" style="display:none; position:fixed; right:12px; bottom:56px; width:360px; max-height:50vh; overflow:auto; background:#15161a; border:1px solid #333; border-radius:6px; box-shadow:0 8px 24px rgba(0,0,0,0.4); padding:10px; z-index:999;"></div>
      <section id="kick-report-container" style="display:none; margin-top:12px;"></section>
    </main>
  </div>

  <script type="text/javascript">
    const statusEl = document.getElementById('status');
  const progressCounter = document.getElementById('progress-counter');
    const raportContainer = document.getElementById('raport-container');
    const btnReport = document.getElementById('btn-report');
    const btnKick = document.getElementById('btn-kick');
    const spinner = document.getElementById('spinner');
    const refreshTimerEl = document.getElementById('refresh-timer');
    const progressFillEl = document.getElementById('progress-fill');
    const progressCounterKick = document.getElementById('progress-counter-kick');
    const progressFillElKick = document.getElementById('progress-fill-kick');
    const twitchProgressBar = document.getElementById('twitch-progress-bar');
    // Lokalne przyciski z fragmentu Twitch bƒôdƒÖ podpinane po wstrzykniƒôciu
    const kickProgressContainer = document.getElementById('kick-progress');
    const kickProgressBar = document.getElementById('kick-progress-bar');
    let kickProgressInterval = null;
    let kickStatusPollId = null;
    let kickReadyPollId = null;
    let kickFinishedHideTimeoutId = null;


    let reportReadyPoll = null;
    let reportStatusPoll = null;
    // Lokalny timer 15-minutowy i lekkie pollowanie tylko podczas generowania
    let nextRunAt = null;            // ms timestamp nastƒôpnego uruchomienia (lokalny)
    let countdownTimerId = null;     // setInterval id dla lokalnego odliczania
    let autoGenPollId = null;        // setInterval id pollowania statusu w trakcie generowania
    let autoGenReadyPollId = null;   // setInterval id pollowania gotowo≈õci raportu (Twitch)
    let autoGenKickReadyPollId = null; // setInterval id pollowania gotowo≈õci raportu Kick (cicho)
    let ensureKickMountPollId = null;  // sta≈Çy stra≈ºnik: je≈õli gotowy i kontener pusty, dociƒÖgnij fragment
    let autoGenActive = false;       // flaga: czy aktualnie trwa generowanie
    let autoTriggerStarted = false;  // stra≈ºnik: czy auto-trigger tego cyklu ju≈º wystartowa≈Ç
    let autoGenSeenActive = false;   // stra≈ºnik: czy w bie≈ºƒÖcym cyklu status by≈Ç aktywny
    let ensureTwitchMountPollId = null; // stra≈ºnik: po reloadzie dociƒÖgnij fragment Twitch, je≈õli gotowy
    // Guardy przeciw wielokrotnemu wczytaniu i wstrzykniƒôciu fragmentu Twitch
    if (typeof window.twitchFragmentLoaded === 'undefined') window.twitchFragmentLoaded = false;
    if (typeof window.twitchFragmentLoading === 'undefined') window.twitchFragmentLoading = false;
    // Guard na r√≥wnoleg≈Çe zapytania /api/report-ready
    let readyFetchLock = false;
    // Guard na r√≥wnoleg≈Çe zapytania /api/report-status
    let statusFetchLock = false;
    

    // Guardy przeciw wielokrotnemu wczytaniu i wstrzykniƒôciu fragmentu Twitch (duplikat ‚Äì usu≈Ñ)
    // [cleanup] usuniƒôto podw√≥jnƒÖ deklaracjƒô let twitchFragmentLoaded/twitchFragmentLoading

    // Ostatni znany status i koordynacja pollowania miƒôdzy wieloma podglƒÖdami
    let latestStatus = null;
    const LEADER_KEY = 'pollLeaderV1';
    const LATEST_STATUS_KEY = 'latestStatusV1';
    const LEADER_TTL_MS = 5000;
    const leaderId = Math.random().toString(36).slice(2);
    let isPollLeader = true; // leader disabled: ka≈ºda karta dzia≈Ça samodzielnie
    let leaderHeartbeatId = null;
    const nowMs = ()=>Date.now();
    const readLeader = ()=>{ try { return JSON.parse(localStorage.getItem(LEADER_KEY)||'null'); } catch{ return null; } };
    const writeLeader = (obj)=>{ try { localStorage.setItem(LEADER_KEY, JSON.stringify(obj)); } catch{} };
    const readLatest = ()=>{ try { return JSON.parse(localStorage.getItem(LATEST_STATUS_KEY)||'{}'); } catch{ return {}; } };
    const writeLatest = (p)=>{ try { localStorage.setItem(LATEST_STATUS_KEY, JSON.stringify(p||{})); } catch{} };
    function acquireLeaderIfPossible(){
      const cur = readLeader();
      const expired = !cur || !cur.ts || ((nowMs()-cur.ts) > LEADER_TTL_MS);
      if (expired || (cur && cur.id === leaderId)){
        isPollLeader = true;
        writeLeader({ id: leaderId, ts: nowMs() });
        if (leaderHeartbeatId) clearInterval(leaderHeartbeatId);
        leaderHeartbeatId = setInterval(()=>{ writeLeader({ id: leaderId, ts: nowMs() }); }, 2000);
      } else {
        isPollLeader = false;
        if (leaderHeartbeatId) { clearInterval(leaderHeartbeatId); leaderHeartbeatId = null; }
      }
    }
    function releaseLeader(){
      const cur = readLeader();
      if (cur && cur.id === leaderId){ try { localStorage.removeItem(LEADER_KEY); } catch{} }
      isPollLeader = false;
      if (leaderHeartbeatId) { clearInterval(leaderHeartbeatId); leaderHeartbeatId = null; }
    }
    window.addEventListener('storage', (e)=>{ if (e.key === LEADER_KEY) acquireLeaderIfPossible(); });
    document.addEventListener('visibilitychange', ()=>{ if (document.hidden) releaseLeader(); else acquireLeaderIfPossible(); });
    window.addEventListener('beforeunload', releaseLeader);
    setTimeout(acquireLeaderIfPossible, 0);

    // Obserwator: uruchamiaj oznaczanie NOWE po wstrzykniƒôciu/zmianie tre≈õci raportu
    function debounce(fn, wait){
      let t;
      return function(...args){
        try{ clearTimeout(t); }catch{}
        t = setTimeout(()=>{ try{ fn.apply(this, args); }catch{} }, wait);
      };
    }
    function setupMarkObservers(){
      try{
        const runMark = (root)=>{ if (!root) return; try{ markNewRowsAfterInject(root); updateGlobalCounters(); }catch{} };
        const twitchRoot = document.getElementById('raport-container');
        const kickRoot = document.getElementById('kick-report-container');
        const opts = { childList: true, subtree: true };
        if (twitchRoot){
          const obsT = new MutationObserver(debounce(()=>runMark(twitchRoot), 120));
          obsT.observe(twitchRoot, opts);
          runMark(twitchRoot);
          window.twitchMarkObserver = obsT;
        }
        if (kickRoot){
          const obsK = new MutationObserver(debounce(()=>runMark(kickRoot), 120));
          obsK.observe(kickRoot, opts);
          runMark(kickRoot);
          window.kickMarkObserver = obsK;
        }
      }catch{}
    }
    try{ setupMarkObservers(); }catch{}

    // Centralne czyszczenie wszystkich interwa≈Ç√≥w zwiƒÖzanych z pollowaniem
    function stopAllIntervals(){
      try{ if (autoGenPollId) { clearInterval(autoGenPollId); autoGenPollId = null; } }catch{}
      try{ if (autoGenReadyPollId) { clearInterval(autoGenReadyPollId); autoGenReadyPollId = null; } }catch{}
      try{ if (reportStatusPoll) { clearInterval(reportStatusPoll); reportStatusPoll = null; } }catch{}
      try{ if (reportReadyPoll) { clearInterval(reportReadyPoll); reportReadyPoll = null; } }catch{}
      try{ if (ensureTwitchMountPollId) { clearInterval(ensureTwitchMountPollId); ensureTwitchMountPollId = null; } }catch{}
      try{ if (ensureKickMountPollId) { clearInterval(ensureKickMountPollId); ensureKickMountPollId = null; } }catch{}
      try{ if (kickStatusPollId) { clearInterval(kickStatusPollId); kickStatusPollId = null; } }catch{}
      try{ if (kickReadyPollId) { clearInterval(kickReadyPollId); kickReadyPollId = null; } }catch{}
      // nie czy≈õcimy countdownTimerId ‚Äì timer ma dzia≈Çaƒá w trybie idle
    }

    // Selewtywne czyszczenie interwa≈Ç√≥w Twitch, bez ruszania pollowania Kick
    function stopTwitchIntervalsOnly(){
      try{ if (autoGenPollId) { clearInterval(autoGenPollId); autoGenPollId = null; } }catch{}
      try{ if (autoGenReadyPollId) { clearInterval(autoGenReadyPollId); autoGenReadyPollId = null; } }catch{}
      try{ if (reportStatusPoll) { clearInterval(reportStatusPoll); reportStatusPoll = null; } }catch{}
      try{ if (reportReadyPoll) { clearInterval(reportReadyPoll); reportReadyPoll = null; } }catch{}
      try{ if (ensureTwitchMountPollId) { clearInterval(ensureTwitchMountPollId); ensureTwitchMountPollId = null; } }catch{}
      // kickStatusPollId / kickReadyPollId / ensureKickMountPollId pozostajƒÖ aktywne
    }

    // Globalny licznik: sumuje Twitch + Kick (definicja na g√≥rze, aby uniknƒÖƒá b≈Çƒôd√≥w widoczno≈õci)
    function updateGlobalCounters(){
      try{
        const counterEl = document.getElementById('global-count');
        if (!counterEl) return;
        // Pobierz wiersze z obu raport√≥w (oba u≈ºywajƒÖ id `report-table` w fragmentach)
        const rows = Array.from(document.querySelectorAll('#report-table tbody tr'));
        let viewedArr = []; let newPendingArr = [];
        try { viewedArr = JSON.parse(localStorage.getItem('viewedClips')||'[]')||[]; } catch{}
        try { newPendingArr = JSON.parse(localStorage.getItem('newPendingClipIds')||'[]')||[]; } catch{}
        const viewedSet = new Set(viewedArr); const newPendingSet = new Set(newPendingArr);
        const clipIdFromUrl = (url)=>{ try{ const u = new URL(url); let last = u.pathname.split('/').filter(Boolean).pop()||'clip'; last = last.split('?')[0]; return last.replace(/[^a-zA-Z0-9_-]/g,'')||'clip'; }catch{ return 'clip'; } };
        let total = 0, newUnviewed = 0, viewedCount = 0;
        rows.forEach(tr=>{
          const cb = tr.querySelector('.clip-select');
          const url = cb ? cb.dataset.url : (tr.querySelector('a[href]')?.getAttribute('href')||'');
          const id = clipIdFromUrl(url);
          total++;
          const isViewed = viewedSet.has(id);
          const isNewPending = newPendingSet.has(id);
          if (isViewed) viewedCount++;
          if (isNewPending && !isViewed) newUnviewed++;
        });
        counterEl.textContent = `Nowe: ${newUnviewed} / Wszystkie: ${total} ‚Ä¢ Obejrzane: ${viewedCount}`;
      }catch{}
    }

    function formatMMSS(sec){
      try{ sec = Math.max(0, Math.floor(Number(sec)||0)); }catch{ sec = 0; }
      const m = Math.floor(sec/60); const s = sec%60;
      return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }

    // Wylicz lokalnie najbli≈ºsze 10 min (00, 10, 20, 30, 40, 50)
    function calcNextDecaminTimestamp(){
      const now = new Date();
      const s = now.getSeconds();
      const ms = now.getMilliseconds();
      const remainder = now.getMinutes() % 10;
      let addMin = 10 - remainder;
      // je≈õli jeste≈õmy idealnie na kwadransie, przejd≈∫ do nastƒôpnego
      if (remainder === 0 && s === 0 && ms === 0) addMin = 10;
      const nextMs = now.getTime() + addMin*60*1000 - s*1000 - ms;
      return nextMs;
    }

    function updateCountdown(){
      if (!nextRunAt){
        if (refreshTimerEl) refreshTimerEl.textContent = '--:--';
        return;
      }
      const now = Date.now();
      let diffSec = Math.floor((nextRunAt - now) / 1000);
      if (diffSec < 0) diffSec = 0;
      if (refreshTimerEl) refreshTimerEl.textContent = formatMMSS(diffSec);
      // Po doj≈õciu do zera: zawsze przeskocz na kolejne okno odliczania,
      // aby licznik nie "sta≈Ç" na 00:00 (nawet gdy trwa generowanie).
      if (diffSec === 0){
        nextRunAt = calcNextDecaminTimestamp();
        // Uruchom generowanie tylko raz, gdy nie trwa aktywny cykl
        if (!autoGenActive && !autoTriggerStarted){
          autoTriggerGeneration();
        }
      }
    }

    function startCountdown(){
      if (countdownTimerId) clearInterval(countdownTimerId);
      updateCountdown();
      countdownTimerId = setInterval(updateCountdown, 1000);
    }

    async function checkReadyOnce(){
      if (readyFetchLock) return false;
      readyFetchLock = true;
      try{
        const rr = await fetch('/api/report-ready');
        const rj = await rr.json();
        return !!(rj && rj.ready);
      }catch(e){ return false; }
      finally { readyFetchLock = false; }
    }

    function stopAutoGenerationPolling(){
      autoGenActive = false;
      if (autoGenPollId){ clearInterval(autoGenPollId); autoGenPollId = null; }
      if (autoGenReadyPollId){ clearInterval(autoGenReadyPollId); autoGenReadyPollId = null; }
    }

    // Kick: status polling i ≈Çadowanie raportu po gotowo≈õci
    function startKickStatusPolling(fromUserClick){
      console.log(`[Kick] startKickStatusPolling fromUserClick=${!!fromUserClick}`);
      // natychmiastowy odczyt
      (async ()=>{
        try{
          const r0 = await fetch('/api/report-kick-status', { cache: 'no-store' });
          const d0 = await r0.json();
          const p0 = d0 && d0.progress ? d0.progress : {};
          console.log('[Kick] immediate status:', p0);
          updateKickProgressUI(p0);
        }catch{}
      })();
      // cykliczny status
      if (kickStatusPollId) clearInterval(kickStatusPollId);
      kickStatusPollId = setInterval(async ()=>{
        try{
          const r = await fetch('/api/report-kick-status', { cache: 'no-store' });
          const d = await r.json();
          const p = d && d.progress ? d.progress : {};
          console.log('[Kick] status tick:', p);
          updateKickProgressUI(p);
          if (p.status === 'finished'){
            clearInterval(kickStatusPollId); kickStatusPollId = null;
            console.log('[Kick] status finished ‚Üí pollKick');
            try{ await pollKick(); }catch{}
          }
        }catch{}
      }, 2000);
      // gotowo≈õƒá co kilka sekund
      if (kickReadyPollId) clearInterval(kickReadyPollId);
      kickReadyPollId = setInterval(async ()=>{
        try{
          const rk = await fetch('/api/report-kick-ready', { cache: 'no-store' }).then(r=>r.json());
          console.log('[Kick] ready tick:', rk);
          if (rk && rk.ready){
            clearInterval(kickReadyPollId); kickReadyPollId = null;
            console.log('[Kick] ready=true ‚Üí pollKick');
            try{ await pollKick(); }catch{}
          }
        }catch{}
      }, fromUserClick ? 3000 : 5000);
    }

    function updateKickProgressUI(p){
      const st = p && p.status ? p.status : 'idle';
      const total = Number(p && p.total || 0);
      let label = '‚Äî'; let pct = 0;
      if (st === 'scraping'){
        label = '‚è≥ Skrobanie klip√≥w‚Ä¶'; pct = 5;
        if (kickProgressContainer) kickProgressContainer.style.display = 'block';
        if (kickProgressBar) kickProgressBar.style.display = 'block';
      } else if (st === 'generating'){
        label = total>0 ? `üîß Generowanie‚Ä¶ (klipy: ${total})` : 'üîß Generowanie‚Ä¶';
        pct = total>0 ? 70 : 50;
        if (kickProgressContainer) kickProgressContainer.style.display = 'block';
        if (kickProgressBar) kickProgressBar.style.display = 'block';
      } else if (st === 'finished'){
        label = '‚úÖ Gotowe'; pct = 100;
        if (kickProgressBar) kickProgressBar.style.display = 'none';
        if (kickProgressContainer) kickProgressContainer.style.display = 'block';
        if (kickFinishedHideTimeoutId) { clearTimeout(kickFinishedHideTimeoutId); }
        kickFinishedHideTimeoutId = setTimeout(()=>{
          if (kickProgressContainer) kickProgressContainer.style.display = 'none';
        }, 4000);
      } else {
        label = '‚Äî'; pct = 0;
        if (kickProgressContainer) kickProgressContainer.style.display = 'none';
        if (kickProgressBar) kickProgressBar.style.display = 'none';
      }
      if (progressCounterKick) progressCounterKick.textContent = label;
      if (progressFillElKick) progressFillElKick.style.width = pct + '%';
    }

    async function autoTriggerGeneration(){
      autoGenActive = true;
      autoTriggerStarted = true;
      autoGenSeenActive = false; // reset global stra≈ºnika aktywno≈õci dla nowego cyklu
      // Reset guard√≥w fragmentu na nowy cykl
      window.twitchFragmentLoaded = false;
      window.twitchFragmentLoading = false;
      // Przed startem nowego cyklu wyczy≈õƒá ewentualne stare interwa≈Çy pollowania
      try { stopAllIntervals(); } catch{}
      // Start generowania Twitch
      try { await fetch('/api/generate-raport'); } catch{}
      try { await fetch('/api/generate-raport-kick'); } catch(e) { console.warn('[Kick][auto] generate error:', e); }
      // Uruchom pollowanie postƒôpu Twitch
      if (twitchProgressBar) twitchProgressBar.style.display = 'block';
      if (progressCounter) { progressCounter.style.display = 'block'; progressCounter.textContent = '‚è≥ Przetworzono: 0 / 0'; }
      startAutoGenerationPolling();
      // Pollowanie Kick uruchamiaj zawsze z auto-triggera
      try{ console.log('[Kick][auto] start status polling'); startKickStatusPolling(false); }catch(e){ console.warn('[Kick][auto] status polling start error:', e); }
    }

    async function startAutoGenerationPolling(){
      autoGenActive = true;
      autoGenSeenActive = false; // reset na poczƒÖtku cyklu auto-pollowania
      // Pollowanie postƒôpu tylko w trakcie generowania (co 3s)
      if (autoGenPollId) clearInterval(autoGenPollId);
      autoGenPollId = setInterval(pollStatus, 3000);
      // Pollowanie gotowo≈õci raportu (co 3s)
      if (autoGenReadyPollId) clearInterval(autoGenReadyPollId);
      autoGenReadyPollId = setInterval(async ()=>{
        try{
          // Korzystaj z ostatniego statusu z pollStatus(), aby uniknƒÖƒá podw√≥jnych wywo≈Ça≈Ñ
          const p = latestStatus || {};
          if (p && p.status && p.status !== 'finished') { autoGenSeenActive = true; }
          if (p && p.status === 'finished' && autoGenSeenActive){
            const ready = await checkReadyOnce();
            if (ready){
              await loadTwitchFragmentOnce();
            }
          }
        }catch{}
      }, 3000);
      // Kick: bez pollowania w stanie idle ‚Äì wznowienie tylko po starcie cyklu
    }

    // Aktualizacja UI Twitch na podstawie statusu (bez fetch)
    function updateTwitchProgressFromStatus(p){
      try{
        const processed = Number(p && p.processed || 0);
        const total = Number(p && p.total || 0);
        const st = p && p.status ? p.status : 'idle';
        latestStatus = p || {};
        if (progressCounter){
          if (st === 'scraping' || st === 'generating' || st === 'running'){
            progressCounter.style.display = 'block';
            progressCounter.textContent = total>0 ? `‚è≥ Przetworzono: ${processed} / ${total}` : '‚è≥ Generowanie‚Ä¶';
          } else {
            progressCounter.style.display = 'none';
            progressCounter.textContent = '';
          }
        }
        if (progressFillEl){
          if (twitchProgressBar) twitchProgressBar.style.display = (st==='finished' || st==='idle') ? 'none' : 'block';
          const pct = total>0 ? Math.floor(processed*100/total) : 0;
          progressFillEl.style.width = pct + '%';
        }
        if (st && st !== 'finished') { autoGenSeenActive = true; }
      }catch{}
    }

    async function pollStatus(){
      // Nie pollowaƒá poza aktywnym cyklem
      if (!autoGenActive) return;
      // Guard przed r√≥wnoleg≈Çymi wywo≈Çaniami /api/report-status
      if (statusFetchLock) return;
      statusFetchLock = true;
      try{
        const rs = await fetch('/api/report-status');
        const data = await rs.json();
        const p = (data && data.progress) ? data.progress : {};
        latestStatus = p;
        writeLatest(p);
        updateTwitchProgressFromStatus(p);
        // Oznacz aktywno≈õƒá cyklu gdy status jest inny ni≈º 'finished'
        if (p && p.status && p.status !== 'finished') {
          autoGenSeenActive = true;
        }
        // Je≈õli status zako≈Ñczony i wcze≈õniej widziano aktywno≈õƒá ‚Äî wstrzyknij fragment bez rƒôcznego od≈õwie≈ºania
        if ((p.status === 'finished') && autoGenSeenActive) {
          try {
            const ready = await checkReadyOnce();
            if (ready) {
              await loadTwitchFragmentOnce();
            }
          } catch{}
        }
      }catch(e){ /* ignore */ }
      finally { statusFetchLock = false; }
    }

    document.getElementById('btn-kick').onclick = async () => {
      if (btnKick.disabled) return;
      btnKick.disabled = true;
      const prevTxt = btnKick.textContent;
      btnKick.textContent = 'Generujƒô‚Ä¶';
      spinner.style.display = 'inline-block';
      // Wyzeruj pasek postƒôpu Kick i uruchom pollowanie statusu
      if (progressCounterKick) { progressCounterKick.textContent = '‚è≥ Generowanie‚Ä¶'; }
      if (progressFillElKick) { progressFillElKick.style.width = '0%'; }
      if (kickProgressContainer) kickProgressContainer.style.display = 'block';
      if (kickProgressBar) kickProgressBar.style.display = 'block';
      try {
        await fetch('/api/generate-raport-kick');
        startKickStatusPolling(true);
      } finally {
        btnKick.disabled = false;
        btnKick.textContent = prevTxt;
        spinner.style.display = 'none';
      }
    };

function pollKick() {
  return fetch('/api/report-kick-ready', { cache: 'no-store' })
    .then(r=>r.json())
    .then(async (j) => {
      if (j && j.ready) {
        const bust = Date.now();
        const html = await fetch(`/raport-kick-fragment?v=${bust}`, { cache: 'no-store' }).then(r=>r.text());
        const kc = document.getElementById('kick-report-container');
        if (kc) {
          kc.innerHTML = html;
          try { kc.style.display = 'block'; } catch{}
          try { markNewRowsAfterInject(kc); } catch{}
          initReportFiltersAndStats(kc);
          // Zatrzymaj animacjƒô i poka≈º 100%
          if (kickProgressInterval) { clearInterval(kickProgressInterval); kickProgressInterval = null; }
          if (progressFillElKick) { progressFillElKick.style.width = '100%'; }
          if (progressCounterKick) { progressCounterKick.textContent = '‚úÖ Gotowe'; }
          try { updateGlobalCounters(); } catch{}
          if (kickProgressBar) kickProgressBar.style.display = 'none';
          if (kickFinishedHideTimeoutId) { clearTimeout(kickFinishedHideTimeoutId); }
          kickFinishedHideTimeoutId = setTimeout(()=>{
            if (kickProgressContainer) kickProgressContainer.style.display = 'none';
          }, 4000);
          // Proaktywnie zatrzymaj pollowanie Kick po wstrzykniƒôciu raportu
          if (kickStatusPollId) { clearInterval(kickStatusPollId); kickStatusPollId = null; }
          if (kickReadyPollId) { clearInterval(kickReadyPollId); kickReadyPollId = null; }
          if (ensureKickMountPollId) { clearInterval(ensureKickMountPollId); ensureKickMountPollId = null; }
          return true;
        }
      }
      return false;
    })
    .catch(()=>false);
}

    // 1) Od√Ö‚Ä∫wie√Ö¬º streamer√É¬≥w
    async function runUpdate() {
      const btn = document.getElementById('btn-update');
      if (btn.disabled) return;
      btn.disabled = true;
      const prev = btn.textContent;
      btn.textContent = 'Od√Ö‚Ä∫wie√Ö¬ºam√¢‚Ç¨¬¶';
      statusEl.textContent = 'üîÑ Od≈õwie≈ºanie streamer√≥w‚Ä¶';
      try {
        const res = await fetch('/api/update-streamers');
        const obj = await res.json();
        statusEl.textContent = obj.message || obj.error;
      } catch (e) {
        statusEl.textContent = 'B√Ö‚Äö√Ñ‚Ä¶d: ' + e;
      } finally {
        btn.disabled = false;
        btn.textContent = prev;
      }
    }

    // 2) Generowanie raportu i pollowanie gotowo√Ö‚Ä∫ci
    async function runReport() {
      const btn = btnReport;
      if (btn.disabled) return;
      // Przed rƒôcznym startem wyczy≈õƒá wszystkie interwa≈Çy pollowania
      try { stopTwitchIntervalsOnly(); } catch{}
      // Reset guard√≥w fragmentu przy rƒôcznym starcie cyklu
      window.twitchFragmentLoaded = false;
      window.twitchFragmentLoading = false;
      btn.disabled = true;
      const prev = btn.textContent;
      // Zabezpieczenie przed podw√≥jnym uruchomieniem (zbieg z autoTriggerem)
      autoGenActive = true;
      autoTriggerStarted = true;
      autoGenSeenActive = false; // wyzeruj globalny stra≈ºnik dla rƒôcznego cyklu
      let hasSeenActive = false; // lokalny stra≈ºnik dla tego cyklu
      btn.textContent = 'Generujƒô‚Ä¶';
      statusEl.textContent = 'üïí Rozpoczynam generowanie‚Ä¶';
      spinner.style.display = 'inline-block';
      if (progressCounter) {


      progressCounter.style.display = 'block';
      progressCounter.textContent = '‚è≥ Przetworzono: 0 / 0';
      }
      if (progressFillEl){ progressFillEl.style.width = '0%'; }
      try {
        await fetch('/api/generate-raport');
        statusEl.textContent = '‚åõ Czekam na raport‚Ä¶';
        // U≈ºywaj wy≈ÇƒÖcznie wsp√≥lnego mechanizmu auto-pollowania
        startAutoGenerationPolling();
        // Upewnij siƒô, ≈ºe Kick dalej pollowany podczas rƒôcznego cyklu Twitch
        try { startKickStatusPolling(true); } catch(e) { console.warn('[Kick][manual] status polling start error:', e); }
      } catch (e) {
        statusEl.textContent = 'B√Ö‚Äö√Ñ‚Ä¶d: ' + e;
        btn.disabled = false;
        btn.textContent = prev;
        spinner.style.display = 'none';
        if (progressCounter) {
          progressCounter.style.display = 'none';
          progressCounter.textContent = '';
        }
        if (progressFillEl){ progressFillEl.style.width = '0%'; }
        if (twitchProgressBar){ twitchProgressBar.style.display = 'none'; }
        if (reportReadyPoll) { clearInterval(reportReadyPoll); reportReadyPoll = null; }
        if (reportStatusPoll) { clearInterval(reportStatusPoll); reportStatusPoll = null; }
      }
    }

    // 3) Pobranie i wstrzykni√Ñ‚Ñ¢cie fragmentu raportu
    async function loadReportFragment() {
      const html = await fetch('/raport-fragment').then(r => r.text());
      // Stra≈ºnik: wstrzyknij raport tylko, je≈õli sƒÖ wiersze tabeli (realne dane)
      try {
        const tmp = document.createElement('div');
        tmp.innerHTML = html;
        const hasRows = tmp.querySelectorAll('#report-table tbody tr').length > 0;
        if (!hasRows) {
          // Nie pokazuj pustego raportu
          return false;
        }
      } catch {}
      raportContainer.innerHTML = html;
      try { raportContainer.style.display = 'block'; } catch{}
      try { initReportFiltersAndStats(raportContainer); } catch{}
      // Usuniƒôto lokalne przyciski; u≈ºywamy globalnego paska i overlayu zapisanych
      (function bindGlobalEditorButtons(){
        const proceedFixed = document.getElementById('fallback-proceed-editor');
        const viewSavedFixed = document.getElementById('fallback-view-saved');
        if (proceedFixed && !proceedFixed.dataset.bound){
          proceedFixed.dataset.bound = '1';
          proceedFixed.addEventListener('click', (e)=>{
            e.preventDefault();
            if (proceedFixed.disabled) return;
            const selected = savedAll();
            try {
              localStorage.setItem('pendingSelection', JSON.stringify({ clips: selected }));
              window.location.assign('/editor');
            } catch (e) {
              alert('Nie uda≈Ço siƒô zapisaƒá wyboru: ' + e);
            }
          });
        }
        if (viewSavedFixed && !viewSavedFixed.dataset.bound){
          viewSavedFixed.dataset.bound = '1';
          viewSavedFixed.addEventListener('click', (e)=>{
            e.preventDefault();
            let panel = document.getElementById('saved-clips-panel');
            if (!panel){
              panel = document.createElement('div');
              panel.id = 'saved-clips-panel';
              panel.className = 'saved-panel';
              panel.style.display = 'none';
              panel.style.position = 'fixed';
              panel.style.right = '16px';
              panel.style.bottom = '64px';
              panel.style.background = '#fafafa';
              panel.style.border = '1px solid #ddd';
              panel.style.borderRadius = '6px';
              panel.style.padding = '8px';
              panel.style.maxWidth = '360px';
              panel.style.zIndex = '9998';
              document.body.appendChild(panel);
            }
            if (panel.style.display === 'none' || !panel.style.display){ renderSavedPanel(panel); panel.style.display = 'block'; }
            else { panel.style.display = 'none'; }
          });
        }
        updateProceedState();
      })();
      initReportFiltersAndStats(raportContainer);
      // Po wstrzykniƒôciu: oznacz NOWE (trwa≈Çe do klikniƒôcia) i aktualizuj pamiƒôƒá
      markNewRowsAfterInject(raportContainer);
      try { updateGlobalCounters(); } catch{}
    }

    // Wstrzykniƒôcie fragmentu Twitch tylko raz i zatrzymanie ca≈Çego pollowania
    async function loadTwitchFragmentOnce(){
      if (window.twitchFragmentLoaded || window.twitchFragmentLoading) return false;
      window.twitchFragmentLoading = true;
      let ok = false;
      try {
        if (typeof window.loadReportFragment === 'function'){
          ok = await window.loadReportFragment();
        } else {
          ok = await loadReportFragment();
        }
      } catch(e){ ok = false; }
      // Niezale≈ºnie od powodzenia wstrzykniƒôcia ‚Äî zako≈Ñcz cykl i zatrzymaj pollowanie
      try { stopTwitchIntervalsOnly(); } catch{}
      autoGenActive = false;
      autoTriggerStarted = false;
      autoGenSeenActive = false;
      try{ if (twitchProgressBar) twitchProgressBar.style.display = 'none'; }catch{}
      try{ if (progressCounter) { progressCounter.style.display = 'none'; progressCounter.textContent = ''; } }catch{}
      try{ if (progressFillEl) progressFillEl.style.width = '0%'; }catch{}
      nextRunAt = calcNextDecaminTimestamp();
      startCountdown();
      window.twitchFragmentLoading = false;
      window.twitchFragmentLoaded = (ok !== false);
      return window.twitchFragmentLoaded;
    }

    // Oznaczanie nowych i obejrzanych po wstrzykniƒôciu fragmentu
    function markNewRowsAfterInject(root){
      if (!root) return;
      // Odczytaj dotychczasowe zbiory
      let known = [];
      let newPending = [];
      let viewed = [];
      try { known = JSON.parse(localStorage.getItem('knownClipIds')||'[]')||[]; } catch{}
      try { newPending = JSON.parse(localStorage.getItem('newPendingClipIds')||'[]')||[]; } catch{}
      try { viewed = JSON.parse(localStorage.getItem('viewedClips')||'[]')||[]; } catch{}
      const knownSet = new Set(known);
      const newPendingSet = new Set(newPending);
      const viewedSetLocal = new Set(viewed);

      const rows = Array.from(root.querySelectorAll('#report-table tbody tr'));
      const currentIds = [];
      rows.forEach(tr=>{
        const cb = tr.querySelector('.clip-select');
        const url = cb ? cb.dataset.url : (tr.querySelector('a[href]')?.getAttribute('href')||'');
        const id = window.clipIdFrom ? window.clipIdFrom(url) : url;
        currentIds.push(id);
      });
      // Zaktualizuj known (dodaj bie≈ºƒÖce id)
      const updatedKnown = Array.from(new Set([...knownSet, ...currentIds]));
      // NOWE = wszystkie nieobejrzane z bie≈ºƒÖcego widoku + poprzednie, po odfiltrowaniu obejrzanych
      const perContainerNew = currentIds.filter(id => !viewedSetLocal.has(id));
      const updatedNewPending = Array.from(new Set([...newPendingSet, ...perContainerNew])).filter(id=>!viewedSetLocal.has(id));
      try { localStorage.setItem('knownClipIds', JSON.stringify(updatedKnown)); } catch{}
      try { localStorage.setItem('newPendingClipIds', JSON.stringify(updatedNewPending)); } catch{}

      // Zastosuj klasy CSS w zale≈ºno≈õci od stanu
      const updatedNewSet = new Set(updatedNewPending);
      rows.forEach(tr=>{
        const cb = tr.querySelector('.clip-select');
        const url = cb ? cb.dataset.url : (tr.querySelector('a[href]')?.getAttribute('href')||'');
        const id = window.clipIdFrom ? window.clipIdFrom(url) : url;
        const isViewed = viewedSetLocal.has(id);
        const isNewPending = updatedNewSet.has(id);
        tr.classList.toggle('viewed-row', isViewed);
        tr.classList.toggle('new-row', isNewPending && !isViewed);
        tr.classList.toggle('new-unviewed', isNewPending && !isViewed);
      });
    }

    // 4) Inicjalizacja dropdown√É¬≥w i aplikacja filtr√É¬≥w
function initReportFiltersAndStats(root) {
  if (!root) return;

  // Globalny stan obejrzanych i filtra
  const hideViewedBtn = document.getElementById('btn-hide-viewed');
  const globalCountEl = document.getElementById('global-count');
  let viewedSet = new Set();
  try { viewedSet = new Set(JSON.parse(localStorage.getItem('viewedClips')||'[]').filter(x=>typeof x==='string')); } catch(e){ viewedSet = new Set(); }
  let hideViewed = false;
  try { hideViewed = JSON.parse(localStorage.getItem('hideViewed')||'false'); } catch(e){}
  if (hideViewedBtn){ hideViewedBtn.textContent = hideViewed ? 'Poka≈º obejrzane' : 'Ukryj obejrzane'; }

  // 1. Toggle dropdown√≥w tylko wewnƒÖtrz root
  root.querySelectorAll('.dropdown').forEach(dd => {
    const btn = dd.querySelector('button');
    if (btn) {
      btn.addEventListener('click', () => {
        dd.classList.toggle('open');
      });
    }
  });

  // 2. Pobierz wszystkie wiersze tabeli wewnƒÖtrz root
  const rows = Array.from(root.querySelectorAll('#report-table tbody tr'));

  // Zaznacz jako obejrzany po klikniƒôciu linku
  root.addEventListener('click', (e)=>{
    const a = e.target.closest('a[href]');
    if (!a) return;
    if (!root.contains(a)) return;
    const tr = a.closest('tr');
    if (!tr) return;
    const cb = tr.querySelector('.clip-select');
    const url = cb ? cb.dataset.url : a.getAttribute('href');
    const id = clipIdFromUrl(url);
    if (!viewedSet.has(id)){
      viewedSet.add(id);
      try { localStorage.setItem('viewedClips', JSON.stringify(Array.from(viewedSet))); } catch(e){}
    }
    // Usu≈Ñ z pending nowych je≈õli zosta≈Ç obejrzany
    try {
      const pending = JSON.parse(localStorage.getItem('newPendingClipIds')||'[]')||[];
      const updated = pending.filter(x=>x!==id);
      localStorage.setItem('newPendingClipIds', JSON.stringify(updated));
    } catch(e){}
    // Re-render bez reloadu (po klikniƒôciu i tak otwiera siƒô karta, ale UI od≈õwie≈ºamy natychmiast)
    applyFiltersAndStats();
    try { updateGlobalCounters(); } catch{}
  }, true);

  // Czy w tym widoku istnieje filtrowanie po kategoriach?
  const hasCategoryFiltering = root.querySelectorAll('.filter-category').length > 0;

  // Pomocnicze: id klipu z data-url (deklaracja funkcji hoistowana)
  function clipIdFromUrl(url){
    try{
      const u = new URL(url);
      let last = u.pathname.split('/').filter(Boolean).pop()||'clip';
      last = last.split('?')[0];
      return last.replace(/[^a-zA-Z0-9_-]/g,'')||'clip';
    }catch{ return 'clip'; }
  }

  // 3. Funkcja filtrujƒÖca + aktualizujƒÖca statystyki
  function applyFiltersAndStats() {
    // a) streamerzy
    const ignoredStreamers = new Set(
      Array.from(root.querySelectorAll('.filter-streamer'))
        .filter(cb => !cb.checked).map(cb => cb.value)
    );
    // b) kategorie (opcjonalne)
    const ignoredCategories = new Set(
      hasCategoryFiltering
        ? Array.from(root.querySelectorAll('.filter-category'))
            .filter(cb => !cb.checked).map(cb => cb.value)
        : []
    );

    let newCount = 0;
    // Odczytaj bie≈ºƒÖce newPending (NOWE)
    let newPendingArr = [];
    try { newPendingArr = JSON.parse(localStorage.getItem('newPendingClipIds')||'[]')||[]; } catch{}
    const newPendingSet = new Set(newPendingArr);
    // Tryb pokazywania tylko nowych
    const visible = [];
    rows.forEach(row => {
      const st = row.dataset.streamer;
      const ct = row.dataset.category;
      // ≈πr√≥d≈Ço URL klipu: preferuj przycisk .add-to-editor, inaczej fallback do linku w tytule
      const btn = row.querySelector('.add-to-editor');
      const hrefLink = row.querySelector('a[href]');
      const url = (btn && btn.dataset.url) ? btn.dataset.url : (hrefLink ? hrefLink.getAttribute('href') || '' : '');
      const id = clipIdFromUrl(url);
      const isViewed = viewedSet.has(id);
      const hideByStreamer = ignoredStreamers.has(st);
      const hideByCategory = hasCategoryFiltering ? ignoredCategories.has(ct) : false;
      const hideByViewed = hideViewed && isViewed === true;
      // Stylowanie: obejrzane i nowe
      if (isViewed){
        row.classList.add('viewed-row');
        row.classList.remove('new-unviewed');
      } else {
        row.classList.remove('viewed-row');
        if (row.classList.contains('new-row')) row.classList.add('new-unviewed');
      }
      const isNewPending = newPendingSet.has(id);
      const hide = hideByStreamer || hideByCategory || hideByViewed;
      row.style.display = hide ? 'none' : '';
      if (isNewPending && !isViewed) newCount++;
      if (!hide) visible.push(row);
      // Oznaczenie NOWE w tytule
      const titleLink = row.querySelector('a[title]');
      if (titleLink){
        const baseTitle = titleLink.getAttribute('title') || '';
        const badge = ' [NOWE]';
        if (!isViewed && !baseTitle.includes(' [NOWE]')){
          titleLink.setAttribute('title', baseTitle + badge);
        } else if (isViewed && baseTitle.includes(' [NOWE]')){
          titleLink.setAttribute('title', baseTitle.replace(' [NOWE]',''));
        }
      }
    });

    // c) oblicz statystyki
    const total = visible.length;
    const catCounts = {}, strCounts = {};
    visible.forEach(r => {
      const st = r.dataset.streamer;
      strCounts[st] = (strCounts[st]||0)+1;
      if (hasCategoryFiltering) {
        const ct = r.dataset.category;
        if (ct !== undefined) {
          catCounts[ct] = (catCounts[ct]||0)+1;
        }
      }
    });
    const topCats = hasCategoryFiltering
      ? Object.entries(catCounts).sort((a,b)=>b[1]-a[1]).slice(0,3)
      : [];
    const topStr = Object.entries(strCounts)
      .sort((a,b)=>b[1]-a[1]).slice(0,3);

    // d) wstaw do root, nie do document (i tylko je≈õli elementy istniejƒÖ)
    const totalEl = root.querySelector('#stats-total');
    if (totalEl) totalEl.textContent = total;

    const catsEl = root.querySelector('#stats-categories');
    if (catsEl) catsEl.textContent = topCats.map(([c,n])=>`${c} (${n})`).join(', ');

    const strEl = root.querySelector('#stats-streamers');
    if (strEl) strEl.textContent = topStr.map(([s,n])=>`${s} (${n})`).join(', ');

    // e) lokalne liczniki zostawiamy, globalny licznik zsumujemy poni≈ºej
  }

  // 4. Pod≈ÇƒÖcz przyciski filtr√≥w tylko wewnƒÖtrz root (z guardami)
  const applyStreamersBtn = root.querySelector('#apply-streamers');
  if (applyStreamersBtn) {
    applyStreamersBtn.addEventListener('click', ()=>{
      applyFiltersAndStats();
      const ddS = root.querySelector('#dd-streamers');
      if (ddS) ddS.classList.remove('open');
      try { updateGlobalCounters(); } catch{}
    });
  }

  const applyCategoriesBtn = root.querySelector('#apply-categories');
  if (applyCategoriesBtn) {
    applyCategoriesBtn.addEventListener('click', ()=>{
      applyFiltersAndStats();
      const ddC = root.querySelector('#dd-categories');
      if (ddC) ddC.classList.remove('open');
      try { updateGlobalCounters(); } catch{}
    });
  }

  // 5. Kolejka edytora: dodawanie per klip, zapisane i przej≈õcie
  const proceedBtn = root.querySelector('#twitch-proceed-editor') || root.querySelector('#kick-proceed-editor');
  const viewSavedBtn = root.querySelector('#twitch-view-saved') || root.querySelector('#kick-view-saved');
  const isTwitch = !!root.querySelector('#twitch-report-root');
  const currentSource = isTwitch ? 'Twitch' : 'Kick';
  // Lekki, estetyczny popup (toast) przy g√≥rze ekranu
  function showToast(message, type='info'){
    try{
      let rootEl = document.getElementById('toast-root');
      if (!rootEl){
        rootEl = document.createElement('div');
        rootEl.id = 'toast-root';
        rootEl.style.cssText = 'position:fixed;top:12px;left:50%;transform:translateX(-50%);z-index:9999;display:flex;flex-direction:column;gap:8px;';
        document.body.appendChild(rootEl);
      }
      const t = document.createElement('div');
      t.textContent = message;
      t.style.cssText = 'background:#1f2937;color:#fff;padding:8px 12px;border-radius:8px;box-shadow:0 8px 20px rgba(0,0,0,0.20);border:1px solid rgba(255,255,255,0.08);font-size:14px;opacity:0;transform:translateY(-6px);transition:opacity .25s ease, transform .25s ease;';
      if (type==='success'){ t.style.background = '#14532d'; t.style.borderColor = '#166534'; }
      if (type==='error'){ t.style.background = '#7f1d1d'; t.style.borderColor = '#991b1b'; }
      rootEl.appendChild(t);
      requestAnimationFrame(()=>{ t.style.opacity = '1'; t.style.transform = 'translateY(0)'; });
      setTimeout(()=>{
        t.style.opacity = '0';
        t.style.transform = 'translateY(-6px)';
        setTimeout(()=>{ try{ t.remove(); }catch{} }, 300);
      }, 2500);
    }catch{}
  }
  const readSavedClips = () => { try { return JSON.parse(localStorage.getItem('savedClips')||'[]')||[]; } catch { return []; } };
  const writeSavedClips = (arr) => { try { localStorage.setItem('savedClips', JSON.stringify(arr)); } catch {} };
  // Wsp√≥lna kolejka klip√≥w (Twitch + Kick)
  // Zapisy pozostajƒÖ z polem source, ale operacje UI dzia≈ÇajƒÖ na ca≈Çej li≈õcie
    const savedAll = () => readSavedClips();
    const clipIdFrom = (url)=>{ try{ const u = new URL(url); let last = u.pathname.split('/').filter(Boolean).pop()||url; return last.split('?')[0]; }catch{ return url; } };
    const getProceedBtn = () => document.querySelector('#raport-container #twitch-proceed-editor');
    const updateProceedState = () => {
      const disabled = savedAll().length===0;
      const localProceed = getProceedBtn();
      if (localProceed) localProceed.disabled = disabled;
      const fab = document.getElementById('proceed-fab');
      if (fab) { fab.disabled = disabled; }
      const proceedFixed = document.getElementById('proceed-editor-fixed');
      if (proceedFixed) proceedFixed.disabled = disabled;
      const proceedFallback = document.getElementById('fallback-proceed-editor');
      if (proceedFallback) proceedFallback.disabled = disabled;
    };

    // Global: panel zapisanych (u≈ºywany przez fallback i lokalny panel)
    function renderSavedPanel(panel){
      if (!panel) return;
      const clips = savedAll();
      if (!clips.length){
        panel.innerHTML = '<div class="hint">Brak zapisanych klip√≥w.</div>';
      } else {
        const items = clips.map(c=>`<li data-url="${c.url}"><a href="${c.url}" target="_blank">${(c.title||c.url).replace(/"/g,'&quot;')}</a> <span class="hint">(${c.broadcaster||'?'}${c.source?' ‚Ä¢ '+c.source:''})</span> <button class="btn btn-small remove-saved" data-url="${c.url}">Usu≈Ñ</button></li>`).join('');
        panel.innerHTML = `<div style="margin-bottom:6px;"><strong>Zapisane klipy (${clips.length}):</strong></div><ul style="margin:0; padding-left:20px;">${items}</ul>`;
      }
    }
    // Uczy≈Ñ najwa≈ºniejsze funkcje dostƒôpne globalnie, aby uniknƒÖƒá ReferenceError
    try {
      window.readSavedClips = readSavedClips;
      window.writeSavedClips = writeSavedClips;
      window.savedAll = savedAll;
      window.renderSavedPanel = renderSavedPanel;
      window.clipIdFrom = clipIdFrom;
    } catch {}

    

    // Global fallback: oznaczanie obejrzanych po klikniƒôciu linku w tabeli
    document.addEventListener('click', (e)=>{
      const a = e.target.closest('#raport-container #report-table a[href], #kick-report-container #report-table a[href]');
      if (!a) return;
      const href = a.getAttribute('href')||'';
      const id = (window.clipIdFrom ? window.clipIdFrom(href) : href);
      let viewedSet = new Set();
      try{ viewedSet = new Set(JSON.parse(localStorage.getItem('viewedClips')||'[]')); }catch{}
      if (!viewedSet.has(id)){
        viewedSet.add(id);
        try{ localStorage.setItem('viewedClips', JSON.stringify(Array.from(viewedSet))); }catch{}
      }
      try { if (typeof applyFiltersAndStats === 'function') applyFiltersAndStats(); } catch {}
      try { markViewedRowsGeneric(); } catch{}
      try { updateGlobalCounters(); } catch{}
    }, true);

    // Uniwersalne od≈õwie≈ºenie klas obejrzanych dla Twitch i Kick
    function markViewedRowsGeneric(){
      // Odczyt aktualnego stanu
      let viewedArr = [];
      try { viewedArr = JSON.parse(localStorage.getItem('viewedClips')||'[]')||[]; } catch {}
      const viewedSet = new Set(viewedArr);
      let newPendingArr = [];
      try { newPendingArr = JSON.parse(localStorage.getItem('newPendingClipIds')||'[]')||[]; } catch{}
      const newPendingSet = new Set(newPendingArr);
      let hideViewed = false;
      try { hideViewed = JSON.parse(localStorage.getItem('hideViewed')||'false'); } catch{}
      let showOnlyNew = false;
      try { showOnlyNew = JSON.parse(localStorage.getItem('showOnlyNew')||'false'); } catch{}
      ['#raport-container', '#kick-report-container'].forEach(rootSel=>{
        const root = document.querySelector(rootSel);
        if (!root) return;
        const rows = root.querySelectorAll('#report-table tbody tr');
        rows.forEach(row=>{
          const btn = row.querySelector('.add-to-editor');
          const hrefLink = row.querySelector('a[href]');
          const url = (btn && btn.dataset.url) ? btn.dataset.url : (hrefLink ? hrefLink.getAttribute('href')||'' : '');
          const id = window.clipIdFrom ? window.clipIdFrom(url) : url;
          const isViewed = viewedSet.has(id);
          const isNewPending = newPendingSet.has(id);
          // Aktualizuj klasy, bez ingerencji w display (logikƒô ukrywania robi applyFiltersAndStats)
          row.classList.toggle('viewed-row', isViewed);
          row.classList.toggle('new-row', isNewPending && !isViewed);
          row.classList.toggle('new-unviewed', isNewPending && !isViewed);
          // Nie zmieniaj bezpo≈õrednio row.style.display tutaj, aby nie nadpisaƒá filtr√≥w streamer/kategoria
        });
      });
    }

    // Fallback: poka≈º/ukryj globalne przyciski, gdy nie ma lokalnego przycisku w raporcie
    function toggleFallbackControls(show){
      const fc = document.getElementById('fallback-editor-controls');
      if (!fc) return;
      fc.style.display = show ? 'flex' : 'none';
      updateProceedState();
    }

    // Podpiƒôcie zdarze≈Ñ dla fallback przycisk√≥w
    (function bindFallbackControls(){
      const proceedFallback = document.getElementById('fallback-proceed-editor');
      const viewSavedFallback = document.getElementById('fallback-view-saved');
      if (proceedFallback && !proceedFallback.dataset.bound){
        proceedFallback.dataset.bound = '1';
        proceedFallback.addEventListener('click', (e)=>{
          e.preventDefault();
          if (proceedFallback.disabled) return;
          const selected = savedAll();
          try {
            localStorage.setItem('pendingSelection', JSON.stringify({ clips: selected }));
            window.location.assign('/editor');
          } catch (e) {
            alert('Nie uda≈Ço siƒô zapisaƒá wyboru: ' + e);
          }
        });
      }
      if (viewSavedFallback && !viewSavedFallback.dataset.bound){
        viewSavedFallback.dataset.bound = '1';
        viewSavedFallback.addEventListener('click', (e)=>{
          e.preventDefault();
          let panel = document.getElementById('saved-clips-panel');
          if (!panel){
            panel = document.createElement('div');
            panel.id = 'saved-clips-panel';
            panel.className = 'saved-panel';
            panel.style.display = 'none';
            panel.style.position = 'fixed';
            panel.style.right = '16px';
            panel.style.bottom = '64px';
            panel.style.background = '#fafafa';
            panel.style.border = '1px solid #ddd';
            panel.style.borderRadius = '6px';
            panel.style.padding = '8px';
            panel.style.maxWidth = '360px';
            panel.style.zIndex = '9998';
            document.body.appendChild(panel);
          }
          if (panel.style.display === 'none' || !panel.style.display){ renderSavedPanel(panel); panel.style.display = 'block'; }
          else { panel.style.display = 'none'; }
        });
      }
      updateProceedState();
    })();
    // Je≈õli globalny pasek istnieje, upewnij siƒô, ≈ºe ma podpiƒôte zdarzenia
    (function ensureFixedBarEvents(){
      const proceedFixed = document.getElementById('proceed-editor-fixed');
      const viewSavedFixed = document.getElementById('view-saved-fixed');
      if (proceedFixed && !proceedFixed.dataset.bound){
        proceedFixed.dataset.bound = '1';
        proceedFixed.addEventListener('click', (e)=>{
          e.preventDefault();
          if (proceedFixed.disabled) return;
          const selected = savedAll();
          try { localStorage.setItem('pendingSelection', JSON.stringify({ clips: selected })); window.location.assign('/editor'); }
          catch (e) { alert('Nie uda≈Ço siƒô zapisaƒá wyboru: ' + e); }
        });
      }
      if (viewSavedFixed && !viewSavedFixed.dataset.bound){
        viewSavedFixed.dataset.bound = '1';
        viewSavedFixed.addEventListener('click', (e)=>{
          e.preventDefault();
          let panel = document.querySelector('#raport-container #saved-clips-panel') || document.getElementById('saved-clips-panel');
          if (!panel){
            panel = document.createElement('div');
            panel.id = 'saved-clips-panel';
            panel.className = 'saved-panel';
            panel.style.display = 'none';
            panel.style.position = 'fixed';
            panel.style.right = '16px';
            panel.style.bottom = '64px';
            panel.style.background = '#fafafa';
            panel.style.border = '1px solid #ddd';
            panel.style.borderRadius = '6px';
            panel.style.padding = '8px';
            panel.style.maxWidth = '360px';
            panel.style.zIndex = '9998';
            document.body.appendChild(panel);
          }
          if (panel.style.display === 'none' || !panel.style.display){ renderSavedPanel(panel); panel.style.display = 'block'; }
          else { panel.style.display = 'none'; }
        });
      }
      updateProceedState();
    })();

    // Nowy globalny handler: przyciski ‚ûï/‚úñ w kolumnie ‚ÄûAkcja‚Äù (Twitch + Kick)
    (function bindGlobalAddRemove(){
      function detectSource(url){
        try {
          const u = new URL(url, window.location.origin);
          const h = (u.hostname||'').toLowerCase();
          if (h.includes('kick.com')) return 'Kick';
          if (h.includes('twitch.tv') || h.includes('clips.twitch.tv')) return 'Twitch';
        } catch {}
        return '';
      }
      function syncButtons(url, added){
        try{
          document.querySelectorAll(`.add-to-editor[data-url="${url}"]`).forEach(b=>{
            b.classList.toggle('added', !!added);
            b.textContent = added ? '‚úñ' : '‚ûï';
            b.style.minWidth = '28px';
            b.style.textAlign = 'center';
          });
        }catch{}
      }
      function refreshSavedPanelIfOpen(){
        try{
          const panel = document.getElementById('saved-clips-panel');
          if (panel && panel.style.display !== 'none'){ renderSavedPanel(panel); }
        }catch{}
      }
      // Guard: nie dopuszczaj do wielokrotnego bindowania handlera
      if (!window.__queueToggleBound){
        window.__queueToggleBound = true;
        const onDocClickToggle = (e)=>{
          const btn = e.target.closest('.add-to-editor');
          if (!btn) return;
          e.preventDefault();
          // zatrzymaj propagacjƒô, aby uniknƒÖƒá ewentualnych dubli
          if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
          // Globalny deduplikator: ignoruj kolejne klikniƒôcie tego samego klipu w kr√≥tkim oknie czasowym
          const urlGuard = btn.dataset.url || '';
          const idGuard = clipIdFrom(urlGuard);
          try{
            if (!window.__toggleGuard) window.__toggleGuard = new Map();
            const last = window.__toggleGuard.get(idGuard) || 0;
            const now = performance.now ? performance.now() : Date.now();
            if (now - last < 300) return; // zbyt szybko ‚Äì potraktuj jako duplikat
            window.__toggleGuard.set(idGuard, now);
          }catch{}
          // Lokalny busy-guard na sam przycisk (dla bezpiecze≈Ñstwa)
          if (btn.dataset.busy) return;
          btn.dataset.busy = '1';
          setTimeout(()=>{ try { delete btn.dataset.busy; } catch{} }, 150);

          const url = btn.dataset.url || '';
          const broadcaster = btn.dataset.broadcaster || '';
          const title = btn.dataset.title || '';
          const id = clipIdFrom(url);
          let saved = readSavedClips();
          const exists = saved.some(x=> clipIdFrom(x.url)===id);
          if (exists){
            saved = saved.filter(x=> clipIdFrom(x.url)!==id);
            writeSavedClips(saved);
            syncButtons(url, false);
            try{ showToast('Usuniƒôto z kolejki', 'success'); }catch{}
          } else {
            const source = detectSource(url);
            saved.push({ url, broadcaster, title, source });
            writeSavedClips(saved);
            syncButtons(url, true);
            try{ showToast('Dodano do kolejki edytora', 'success'); }catch{}
          }
          refreshSavedPanelIfOpen();
          updateProceedState();
        };
        document.addEventListener('click', onDocClickToggle);
        // Silny guard: usuwaj i ponownie podpinaj handler przy ka≈ºdej pe≈Çnej wymianie fragmentu raportu,
        // aby uniknƒÖƒá dublowania w sytuacjach dynamicznego montowania (generowanie raportu Twitch/Kick)
        const originalLoadReportFragment = window.loadReportFragment;
        if (typeof originalLoadReportFragment === 'function'){
          window.loadReportFragment = async function(){
            // Zdejmij nas≈Çuch przed pe≈ÇnƒÖ wymianƒÖ fragmentu
            try{ document.removeEventListener('click', onDocClickToggle); }catch{}
            let res;
            try{
              res = await originalLoadReportFragment();
            } finally {
              // Przywr√≥ƒá nas≈Çuch ZAWSZE, nawet je≈õli wystƒÖpi b≈ÇƒÖd/abort
              try{ document.addEventListener('click', onDocClickToggle); }catch{}
            }
            return res;
          };
        }
        const originalPollKick = window.pollKick;
        if (typeof originalPollKick === 'function'){
          window.pollKick = async function(){
            try{ document.removeEventListener('click', onDocClickToggle); }catch{}
            let v;
            try{
              v = await originalPollKick();
            } finally {
              try{ document.addEventListener('click', onDocClickToggle); }catch{}
            }
            return v;
          };
        }
      }
    })();
  // Pasywna synchronizacja UI dla nielider√≥w: nas≈Çuch zmian latestStatus w localStorage
  try{
    window.addEventListener('storage', (e)=>{
      try{
        if (e && e.key === LATEST_STATUS_KEY){
          const p = JSON.parse(e.newValue||'{}');
          updateTwitchProgressFromStatus(p);
        }
      }catch{}
    });
    // Jednorazowa aktualizacja z ostatniego stanu (je≈õli istnieje)
    try{ const p0 = readLatest(); if (p0 && p0.status){ updateTwitchProgressFromStatus(p0); } }catch{}
  }catch{}
  // Inicjalna synchronizacja ikon +/‚úñ z zapisanymi klipami
  (function initAddButtons(){
    try{
      const saved = savedAll();
      document.querySelectorAll('.add-to-editor').forEach(b=>{
        const id = clipIdFrom(b.dataset.url);
        const exists = saved.some(x=>clipIdFrom(x.url)===id);
        if (exists){ b.classList.add('added'); b.textContent = '‚úñ'; }
        else { b.classList.remove('added'); b.textContent = '‚ûï'; }
      });
    }catch{}
  })();
  // Podpinanie lokalnego przycisku po wstrzykniƒôciu fragmentu Twitch

  // 5b. Panel zapisanych + usuwanie (panel lokalny w Twitch fragmencie)
  // Dodawanie pojedynczego klipu z wiersza tabeli
  // (usuniƒôto: lokalny handler klikniƒôƒá .add-to-editor)

  // (usuniƒôto: efekty hover dla .add-to-editor)
  // Usuwanie z panelu zapisanych
  root.addEventListener('click', (e)=>{
    const rm = e.target.closest('.remove-saved');
    if (!rm) return;
    e.preventDefault();
    const url = rm.dataset.url;
    const all = readSavedClips();
    // Usuwamy po id klipu (niezale≈ºnie od ≈∫r√≥d≈Ça), aby kolejka by≈Ça globalna
    const filtered = all.filter(c=>clipIdFrom(c.url) !== clipIdFrom(url));
    writeSavedClips(filtered);
    // Od≈õwie≈º panel tylko je≈õli jest widoczny
    try{
      const panel = document.getElementById('saved-clips-panel');
      if (panel && panel.style.display !== 'none'){ renderSavedPanel(panel); }
    }catch{}
    updateProceedState();
    try{
      // Odblokuj wszystkie odpowiadajƒÖce przyciski w obu raportach
      document.querySelectorAll(`.add-to-editor[data-url="${url}"]`).forEach(rowBtn=>{
        rowBtn.classList.remove('added');
        rowBtn.textContent = '‚ûï';
      });
    }catch{}
  });
  // Globalny overlay: obs≈Çuga usuwania zapisanych poza raportem Twitch/Kick
  document.addEventListener('click', (e)=>{
    const rm = e.target.closest('.remove-saved');
    if (!rm) return;
    // je≈õli klik by≈Ç wewnƒÖtrz root, zosta≈Ç ju≈º obs≈Çu≈ºony powy≈ºej
    if (root.contains(rm)) return;
    e.preventDefault();
    const url = rm.dataset.url;
    const all = readSavedClips();
    const filtered = all.filter(c=>clipIdFrom(c.url) !== clipIdFrom(url));
    writeSavedClips(filtered);
    showToast('Usuniƒôto z kolejki', 'success');
    try{
      document.querySelectorAll(`.add-to-editor[data-url="${url}"]`).forEach(rowBtn=>{
        rowBtn.classList.remove('added');
        rowBtn.textContent = '‚ûï';
      });
    }catch{}
    try{
      const panel = document.getElementById('saved-clips-panel');
      if (panel && panel.style.display !== 'none'){ renderSavedPanel(panel); }
    }catch{}
    updateProceedState();
  });
  // Przycisk "Poka≈º zapisane" lokalny bƒôdzie podpinany po wstrzykniƒôciu

  // 6. Reakcja na przycisk Ukryj/Poka≈º obejrzane
  if (hideViewedBtn){
    hideViewedBtn.addEventListener('click', ()=>{
      hideViewed = !hideViewed;
      try{ localStorage.setItem('hideViewed', JSON.stringify(hideViewed)); }catch(e){}
      hideViewedBtn.textContent = hideViewed ? 'Poka≈º obejrzane' : 'Ukryj obejrzane';
      try { if (typeof applyFiltersAndStats === 'function') applyFiltersAndStats(); } catch{}
      try { markViewedRowsGeneric(); } catch{}
      try { updateGlobalCounters(); } catch{}
    });
  }

  // Przycisk "Poka≈º tylko nowe" / "Poka≈º wszystkie"
  // usuniƒôto przycisk trybu ‚Äûtylko nowe‚Äù, pozostaje filtr obejrzanych

  // Floating FAB: poka≈º przycisk "Dalej do edytora" w prawym dolnym rogu, gdy lokalny przycisk niewidoczny
  function setupProceedFabFor(localBtn){
    let fab = document.getElementById('proceed-fab');
    if (!fab){
      fab = document.createElement('button');
      fab.id = 'proceed-fab';
      fab.className = 'btn fab-proceed';
      fab.textContent = '‚û°Ô∏è Dalej do edytora';
      fab.style.display = 'none';
      document.body.appendChild(fab);
      fab.addEventListener('click', (e)=>{
        e.preventDefault();
        if (fab.disabled) return;
        const selected = savedAll();
        try {
          localStorage.setItem('pendingSelection', JSON.stringify({ clips: selected }));
          window.location.assign('/editor');
        } catch (e) {
          alert('Nie uda≈Ço siƒô zapisaƒá wyboru: ' + e);
        }
      });
    }
    if (!localBtn){ fab.style.display = 'none'; return; }
    try { if (window._fabObserver) { window._fabObserver.disconnect(); } } catch{}
    const io = new IntersectionObserver((entries)=>{
      const visible = entries.some(en=>en.isIntersecting);
      fab.style.display = (!visible) ? 'block' : 'none';
      fab.disabled = savedAll().length===0;
    }, { threshold: 0.3 });
    io.observe(localBtn);
    window._fabObserver = io;
    updateProceedState();
  }

  // 7. Pierwsze wyliczenie
  applyFiltersAndStats();
  updateGlobalCounters();
}

  // (usuniƒôto zduplikowanƒÖ definicjƒô updateGlobalCounters; funkcja jest zdefiniowana na g√≥rze skryptu)

    // Pod√Ö‚Äö√Ñ‚Ä¶czamy eventy do przycisk√É¬≥w
    document.getElementById('btn-update').addEventListener('click', runUpdate);
    document.getElementById('btn-report').addEventListener('click', runReport);
    // Auto-od≈õwie≈ºanie: ca≈Çkowicie lokalny timer bez zapyta≈Ñ do backendu
    window.addEventListener('load', async ()=>{
      console.log('[Kick] window.load: start');
      nextRunAt = calcNextDecaminTimestamp();
      startCountdown();
      // Nie sprawdzaj gotowo≈õci Twitch na starcie; ograniczamy wywo≈Çania API
      // (fragment Twitch zostanie za≈Çadowany dopiero po generowaniu)
      // UWAGA: Na starcie nie odpytywaƒá Kick (status/ready). Uruchamiamy tylko
      // lokalny licznik i Twitch fragment (je≈õli gotowy). Kick odpytujemy dopiero
      // gdy u≈ºytkownik kliknie lub gdy timer dojdzie do zera (autoTriggerGeneration).
      // Wymu≈õ ukrycie UI Kick na starcie (bez generowania)
      try{
        if (kickProgressContainer) kickProgressContainer.style.display = 'none';
        if (kickProgressBar) kickProgressBar.style.display = 'none';
        if (progressCounterKick) progressCounterKick.textContent = '‚Äî';
      }catch{}
      // Zaktualizuj globalny licznik po starcie (guard na istnienie funkcji)
      try { if (typeof updateGlobalCounters === 'function') updateGlobalCounters(); } catch {}
      // Przywr√≥ƒá pasek postƒôpu po od≈õwie≈ºeniu na podstawie ostatniego statusu
      try {
        const persisted = readLatest();
        const st = persisted && persisted.status ? persisted.status : 'idle';
        if (st === 'scraping' || st === 'generating' || st === 'running'){
          // Wznowienie cyklu: poka≈º pasek i uruchom wsp√≥lne pollowanie
          autoGenActive = true;
          autoTriggerStarted = true; // zapobiegaj podw√≥jnemu startowi
          autoGenSeenActive = true;
          try { updateTwitchProgressFromStatus(persisted); } catch{}
          try{ if (twitchProgressBar) twitchProgressBar.style.display = 'block'; }catch{}
          if (autoGenPollId) clearInterval(autoGenPollId);
          if (autoGenReadyPollId) clearInterval(autoGenReadyPollId);
          startAutoGenerationPolling();
        } else if (st === 'finished') {
          // Je≈õli zako≈Ñczone: spr√≥buj wstrzyknƒÖƒá utrwalony raport bez pollowania
          try {
            const isReady = await checkReadyOnce();
            if (isReady) { await loadTwitchFragmentOnce(); }
          } catch{}
          autoGenActive = false;
          autoTriggerStarted = false;
          autoGenSeenActive = false;
          try{ if (twitchProgressBar) twitchProgressBar.style.display = 'none'; }catch{}
          try{ if (progressCounter) { progressCounter.style.display = 'none'; progressCounter.textContent = ''; } }catch{}
          try{ if (progressFillEl) progressFillEl.style.width = '0%'; }catch{}
        } else {
          // Idle: licz wy≈ÇƒÖcznie lokalny countdown, bez pollowania backendu
          autoGenActive = false;
          autoTriggerStarted = false;
          autoGenSeenActive = false;
          try{ if (twitchProgressBar) twitchProgressBar.style.display = 'none'; }catch{}
          try{ if (progressCounter) { progressCounter.style.display = 'none'; progressCounter.textContent = ''; } }catch{}
          try{ if (progressFillEl) progressFillEl.style.width = '0%'; }catch{}
        }
      } catch {}
      // Fallback: je≈õli lokalny przycisk Twitch nie istnieje ‚Üí poka≈º globalne przyciski
      try{
        const hasLocalProceed = !!document.querySelector('#raport-container #twitch-proceed-editor');
        toggleFallbackControls(true);
      }catch{}
      // Stra≈ºnik po reloadzie: je≈õli raport Twitch jest gotowy, a kontener pusty ‚Äî dociƒÖgnij fragment
      try {
        if (ensureTwitchMountPollId) clearInterval(ensureTwitchMountPollId);
        ensureTwitchMountPollId = setInterval(async ()=>{
          try {
            const tc = document.getElementById('raport-container');
            const hasContent = !!(tc && tc.innerHTML && tc.innerHTML.trim().length);
            if (!autoGenActive && !hasContent) {
              const isReady = await checkReadyOnce();
              if (isReady) {
                const injected = await loadTwitchFragmentOnce();
                if (injected && ensureTwitchMountPollId) { clearInterval(ensureTwitchMountPollId); ensureTwitchMountPollId = null; }
              }
            }
          } catch {}
        }, 3000);
      } catch {}
      // Stra≈ºnik po reloadzie: Kick ‚Äì je≈õli gotowy i kontener pusty, dociƒÖgnij fragment bez rƒôcznego od≈õwie≈ºania
      try {
        if (ensureKickMountPollId) clearInterval(ensureKickMountPollId);
        ensureKickMountPollId = setInterval(async ()=>{
          try {
            const kc = document.getElementById('kick-report-container');
            const hasKickContent = !!(kc && kc.innerHTML && kc.innerHTML.trim().length);
            if (!hasKickContent) {
              const rk = await fetch('/api/report-kick-ready', { cache: 'no-store' }).then(r=>r.json());
              if (rk && rk.ready) {
                const bust = Date.now();
                const htmlK = await fetch(`/raport-kick-fragment?v=${bust}`, { cache: 'no-store' }).then(r=>r.text());
                // Poka≈º tylko je≈õli sƒÖ wiersze z danymi
                let canShowKick = false;
                try {
                  const tmpK = document.createElement('div');
                  tmpK.innerHTML = htmlK;
                  canShowKick = tmpK.querySelectorAll('#report-table tbody tr').length > 0;
                } catch {}
                if (kc && canShowKick) {
                  kc.innerHTML = htmlK;
                  try { kc.style.display = 'block'; } catch{}
                  try { markNewRowsAfterInject(kc); } catch{}
                  initReportFiltersAndStats(kc);
                  try { updateGlobalCounters(); } catch{}
                  if (ensureKickMountPollId) { clearInterval(ensureKickMountPollId); ensureKickMountPollId = null; }
                }
              }
            }
          } catch {}
        }, 3000);
      } catch {}
      try {
        // Kick: po za≈Çadowaniu strony uruchom tylko pollowanie statusu,
        // bez natychmiastowego wstrzykiwania starego raportu.
        try { startKickStatusPolling(false); } catch{}
        
      } catch {}
      // Usuniƒôto fallback sta≈Çego paska; wykorzystujemy tylko lokalny przycisk + FAB
    });
  </script>
  <script>
    // Logika lidera wy≈ÇƒÖczona ‚Äî wszystkie karty dzia≈ÇajƒÖ samodzielnie
  </script>
  
  </body>
  </html>
